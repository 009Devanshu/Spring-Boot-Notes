Official Site for Hibernate ORM tool--> www.hibernate.org/orm

Topics
----------
What is Hibernate?
Benefits of Hibernate?
What is JPA?
Benefits of JPA?


What is Hibernate?
----------------------------
A framework for persisting/saving java objects in a database. 

Benefits of Hibernate
----------------------------
Hibernate handles all low level sql.
Minimize the amount of JDBC code you have to develop. 
Hibernate provides Object to Relational Mapping (ORM)

	Object To Relation Mapping(ORM)--> It is mapping between Java class and database tables. 
	-------------------------------------------------------------------------------------------
	Java Class:-								Database Table
	Student									student:			
		-id:int								id INT
		-firstName:String-----------Hibernate-------------------------- first_name varchar(45)
		-lastName:String						last_name varchar(45)
		-email:String							email_varchar(45)
		
What is JPA?
------------------------------
Jakarta Persistence API(JPA) is standard api for Object to Relational Mapping (ORM)
It is only a specification which defines 
	a set of interfaces
	Requires an implementation to be usable
	
	
	JPA Vendor Implementations
	-----------------------------
	Hibernate
	EclipseLink
	
Benefits of JPA Specifications
--------------------------------
	We are not locked in to vendor's implementation
	JPA maintains portable and flexible code by coding to jpa specifications
	Can theoretically switch vendor implementations
		For example,if Vendor ABC stops supporting their product, we can switch to vendor XYZ without vendor without vendor lock in.
	
Note: By default, Spring uses Hibernate as the default JPA vendor. 
	
	
=================================================================================================================================================================================


Saving a Java object with JPA
-------------------------------------------
//create java object
Student theStudent = new Student("Paul","Doe","paul@luv2code.com");

//save the object
entityManager.persist(theStudent);		(Under the hood, it will write sql query to store object in database table)	(EntityManager is from JPA)



Retrieving a Java Object with JPA
---------------------------------------------------

// create Java object
Student theStudent = new Student("Paul", "Doe", "paul@luv2code.com");

// save it to database
entityManager.persist(theStudent);

// now retrieve from database using the primary key
int theId = 1;
Student myStudent = entityManager.find(Student.class, theId);		




Querying for Java objects
--------------------------------------------------
TypedQuery<Student> theQuery = entityManager.createQuery("from Student",Student.class);

List<Student> students = theQuery.getResultList();




=================================================================================================================================================================================

In Spring Boot, based on the configurations, Spring Boot will automatically create the beans for 
	DataSource, EntityManager etc...
	And we can inject these beans in our DAO.
	
	
Dependencies to be added in POM.xml file---->
-----------------------------------------------------
Suppose we are using MySQL database, then dependencies in POM.xml file is---> 
	mysql-connector-j
	spring-boot-starter-data-jpa
	
Configuration in application.properties
-----------------------------------------------------
spring.datasource.url=jdbc:mysql://localhost:3306/student_tracker
spring.datasource.username=springstudent
spring.datasource.password=springstudent



=================================================================================================================================================================================
JPA DEVELOPMENT PROCESS
------------------------------------------------------------------------------------------------------------------------

Entity Class
----------------
At a minimum, the Entity class
	Must be annotated with @Entity
	Must have public or protected no args constructor
		The class can have other constructors.
		


Map class to Database table & Map fields to database table
------------------------------------------------------------------------------
@Entity
@Table(name="student")
public class Student{
	
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	private int id;
	
	@Column(name="first_name")			(first_name is the name of the column in database table student)
	private String firstName;
	
	...
}


Note: 
The use of @Column is optional.
If not specified, it means column name in database table is same as java field.

The use of @Table is optional. 
If not specified, it means name of database table and name of java object are same.



Student DAO
--------------------------------------
	Responsible for interfacing with the database.
	It contains various methods like save(), findById(), findAll(), delete(), deleteById(), update(), deleteAll() etc.
	DAO needs JPA EntityManager which is the main componenet for saving/retrieving entities. 
	

	  CRUD--------------Student<------------->Entity Manager<---------->DataSource<----------------> Database
	  APP		    DAO

What is EntityManager
-------------------------------
EntityManager is the specification of Jakarta Persistence API. 
It is autowired in Database Access Object and used to persiste/store data in database by providing various database specific methods. 
EntityManager needs DataSource. 
Both EntityManager and DataSource are created by SpringBoot based on the information in application.properties and depedencies in pom.xml file.



Defining Student DAO layer:
-------------------------------------------

Student DAO interface:-

public interface StudentDAO{
	void save(Student theStudent);
}

DAO Implementation:

@Repository
public class StudentDAOImpl implements StudentDAO{
	
	private EntityManager entityManager;
	
	@Autowired
	public StudentDAOImpl(EntityManager theEntityManager){
		entityManager = theEntityManager;
	}
	
	@Override
	@Transactional
	public void save(Student theStudent){
		entityManager.save(theStudent);
	}
}


@Transactional:-- Spring provides @Transactoinal annotation which automagically begin and end the transaction for our JPA code (No need to this explicitly in our code)


@Repository:-- It is applied to DAO implementations. Spring Boot will automatically register the DAO implementation as a bean (component-scanning)
Spring also provides translation of any JDBC related exceptions. Translation of JDBC exceptions to Spring's DataAccessException heirarchy is automatic for classes annotated with @Repository. This translation allows you to handle database-related exceptions in a more consistent and Spring-friendly way.



In main application of CommandLine type, to save the Object--->


public class CrudedemoApplication{
	
	public static void main(String[] args) {
		SpringApplication.run(CruddemoApplication.class, args);
	}
	
	public CommandLineRunner commandLineRunner(StudentDAO studentDAO){
		
		return runner-> {
			
			createStudent(studentDAO);
			}
	}
	
	public void createStudent(StudentDAO studentDAO){
		// create the student object
		System.out.println("Creating new student object...");
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
		// save the student object
		System.out.println("Saving the student...");
		studentDAO.save(tempStudent);
		// display id of the saved student
		System.out.println("Saved student. Generated id: " + tempStudent.getId());
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
	}
}


Retrieve the object:-
-----------------------
Student myStudent = entityManager.find(Student.class, 1);		(1 is primary key)



Student DAO interface:-

public interface StudentDAO{
	void save(Student theStudent);
	Student findById(Integer id);
}


DAO Implementation:

@Repository
public class StudentDAOImpl implements StudentDAO{
	
	private EntityManager entityManager;
	
	@Autowired
	public StudentDAOImpl(EntityManager theEntityManager){
		entityManager = theEntityManager;
	}
	
	@Override
	@Transactional
	public void save(Student theStudent){
		entityManager.save(theStudent);
	}
	
	@Override						(No need to add @Transactional since we are doing querying)
	public Student findById(Integer id){
		entityManager.find(Student.class, id);		(If not found, returns null)
	}
}


In Main App:-


public class CrudedemoApplication{
	
	public static void main(String[] args) {
		SpringApplication.run(CruddemoApplication.class, args);
	}
	
	public CommandLineRunner commandLineRunner(StudentDAO studentDAO){
		
		return runner-> {
			
			createStudent(studentDAO);
			readStudent(studentDAO)
		}
	}
	
	public void createStudent(StudentDAO studentDAO){
		// create the student object
		System.out.println("Creating new student object...");
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
		// save the student object
		System.out.println("Saving the student...");
		studentDAO.save(tempStudent);
		// display id of the saved student
		System.out.println("Saved student. Generated id: " + tempStudent.getId());
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
	}
	
	public void readStudent(StudentDAO studentDAO){
		Student tempStudent = new Student("Daffy", "Duck", "daffy@luv2code.com");
		studentDAO.save(tempStudent);
		Student myStudent = studentDAO.findById(tempStudent.getId());
	}
}


=========================================================================================================================================================================================
JPQL
-----------
It is a query language for retrieving objects. 
It is similar to sql and we can use where, having, join etc. 
However, JPQL is based on Entity Name and Entity Fields. 

TypedQuery<Student> theQuery = entitymanager.createQuery("from Student where lastName='Doe'",Student.class);		(Where Student and lastName are Entity Name and Entity fields respectively)			
List<Student> students=theQuery.getResultList();

JPQL Named Paramters:-
-------------------------
public List<Student> findByLastName(String theLastName){

	TypedQuery<Student> theQuery = entityManager.createQuery("from Student where lastName=:theData",Student.class);
	
	theQuery.setParameer("theData",theLastName);
	
	return theQuery.getResultList();
}

JPQL named parameters are prefixed with colon (:)
Think of Named Parameter as a placeholder that is filled in later. 


Student DAO interface:-

public interface StudentDAO{
	void save(Student theStudent);
	Student findById(Integer id);
	List<Student> findAll();
}


DAO Implementation:

@Repository
public class StudentDAOImpl implements StudentDAO{
	
	private EntityManager entityManager;
	
	@Autowired
	public StudentDAOImpl(EntityManager theEntityManager){
		entityManager = theEntityManager;
	}
	
	@Override
	@Transactional
	public void save(Student theStudent){
		entityManager.save(theStudent);
	}
	
	@Override						(No need to add @Transactional since we are doing querying)
	public Student findById(Integer id){
		entityManager.find(Student.class, id);		(If not found, returns null)
	}
	
	@Override
	public List<Student> findAll(){										(No need to add @Transactional because we are doing a query)
		TypedQuery<Student> theQuery = entityManager.createQuery("from Student",Student.class);
		return theQuery.getResultList();
	}
}



public class CrudedemoApplication{
	
	public static void main(String[] args) {
		SpringApplication.run(CruddemoApplication.class, args);
	}
	
	public CommandLineRunner commandLineRunner(StudentDAO studentDAO){
		
		return runner-> {
			
			createStudent(studentDAO);
			readStudent(studentDAO);
			queryForStudents(studentDAO);
		}
	}
	
	public void createStudent(StudentDAO studentDAO){
		// create the student object
		System.out.println("Creating new student object...");
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
		// save the student object
		System.out.println("Saving the student...");
		studentDAO.save(tempStudent);
		// display id of the saved student
		System.out.println("Saved student. Generated id: " + tempStudent.getId());
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
	}
	
	public void readStudent(StudentDAO studentDAO){
		Student tempStudent = new Student("Daffy", "Duck", "daffy@luv2code.com");
		studentDAO.save(tempStudent);
		Student myStudent = studentDAO.findById(tempStudent.getId());
		SOP(myStudent);
	}
	
	public void queryForStudents(StudentDAO studentDAO){
		List<Student> students = studentDAO.findAll();
		
		for(Student tempStudent:students){
			System.out.println(tempStudent);
		}
	}
}



=========================================================================================================================================================================================

Update a Student
---------------------

Student theStudent = entityManager.find(Student.class,1);

theStudent.setFirstName("Scooby");

entityManager.merge(theStudent);		// Update the entity


Update last name for all students
---------------------------------------
int numRowsUpdated = entityManager.createQuery("update Student set lastName='Tester'").executeUpdate();

Return the number of rows updated.




Student DAO interface:-

public interface StudentDAO{
	void save(Student theStudent);
	Student findById(Integer id);
	List<Student> findAll();
	void update(Student theStudent);
}



DAO Implementation:

@Repository
public class StudentDAOImpl implements StudentDAO{
	
	private EntityManager entityManager;
	
	@Autowired
	public StudentDAOImpl(EntityManager theEntityManager){
		entityManager = theEntityManager;
	}
	
	@Override
	@Transactional
	public void save(Student theStudent){
		entityManager.save(theStudent);
	}
	
	@Override						(No need to add @Transactional since we are doing querying)
	public Student findById(Integer id){
		entityManager.find(Student.class, id);		(If not found, returns null)
	}
	
	@Override
	public List<Student> findAll(){										(No need to add @Transactional because we are doing a query)
		TypedQuery<Student> theQuery = entityManager.createQuery("from Student",Student.class);
		return theQuery.getResultList();
	}
	
	@Override
	@Transactional						(Add @Transactional since we are performing update)
	public void update(Student theStudent){
		entityManager.merge(theStudent);
	}
}




public class CrudedemoApplication{
	
	public static void main(String[] args) {
		SpringApplication.run(CruddemoApplication.class, args);
	}
	
	public CommandLineRunner commandLineRunner(StudentDAO studentDAO){
		
		return runner-> {
			
			createStudent(studentDAO);
			readStudent(studentDAO);
			queryForStudents(studentDAO);
			updateStudent(studentDAO)
		}
	}
	
	public void createStudent(StudentDAO studentDAO){
		// create the student object
		System.out.println("Creating new student object...");
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
		// save the student object
		System.out.println("Saving the student...");
		studentDAO.save(tempStudent);
		// display id of the saved student
		System.out.println("Saved student. Generated id: " + tempStudent.getId());
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
	}
	
	public void readStudent(StudentDAO studentDAO){
		Student tempStudent = new Student("Daffy", "Duck", "daffy@luv2code.com");
		studentDAO.save(tempStudent);
		Student myStudent = studentDAO.findById(tempStudent.getId());
		SOP(myStudent);
	}
	
	public void queryForStudents(StudentDAO studentDAO){
		List<Student> students = studentDAO.findAll();
		
		for(Student tempStudent:students){
			System.out.println(tempStudent);
		}
	}
	
	private void updateStudent(studentDAO){
		int studentId = 1;
		Student myStudent = studentDAO.findById(studentId);
		myStudent.setFirstName("Scooby");
		studentDAO.update(myStudent);
	}
}



=========================================================================================================================================================================================
Deleting a Student
---------------------


// retrieve the student
int id = 1;
Student theStudent = entityManager.find(Student.class, id);
// delete the student
entityManager.remove(theStudent);


Delete based on a condition:
-------------------------------
int numRowsDeleted = entityManager.createQuery("DELETE FROM Student WHERE lastName=‘Smith’").executeUpdate();



Student DAO interface:-

public interface StudentDAO{
	void save(Student theStudent);
	Student findById(Integer id);
	List<Student> findAll();
	void update(Student theStudent);
	void delete(Integer id);
}

DAO Implementation:

@Repository
public class StudentDAOImpl implements StudentDAO{
	
	private EntityManager entityManager;
	
	@Autowired
	public StudentDAOImpl(EntityManager theEntityManager){
		entityManager = theEntityManager;
	}
	
	@Override
	@Transactional
	public void save(Student theStudent){
		entityManager.save(theStudent);
	}
	
	@Override						(No need to add @Transactional since we are doing querying)
	public Student findById(Integer id){
		entityManager.find(Student.class, id);		(If not found, returns null)
	}
	
	@Override
	public List<Student> findAll(){										(No need to add @Transactional because we are doing a query)
		TypedQuery<Student> theQuery = entityManager.createQuery("from Student",Student.class);
		return theQuery.getResultList();
	}
	
	@Override
	@Transactional						(Add @Transactional since we are performing update)
	public void update(Student theStudent){
		entityManager.merge(theStudent);
	}
	
	@Override
	@Transactional
	public void delete(Integer id){
		Student theStudent = entityManager.find(Student.class, id);
		entityManager.remove(theStudent);
	}
}



public class CrudedemoApplication{
	
	public static void main(String[] args) {
		SpringApplication.run(CruddemoApplication.class, args);
	}
	
	public CommandLineRunner commandLineRunner(StudentDAO studentDAO){
		
		return runner-> {
			
			createStudent(studentDAO);
			readStudent(studentDAO);
			queryForStudents(studentDAO);
			updateStudent(studentDAO);
			deleteStudent(studentDAO);
		}
	}
	
	public void createStudent(StudentDAO studentDAO){
		// create the student object
		System.out.println("Creating new student object...");
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
		// save the student object
		System.out.println("Saving the student...");
		studentDAO.save(tempStudent);
		// display id of the saved student
		System.out.println("Saved student. Generated id: " + tempStudent.getId());
		Student tempStudent = new Student("Paul", "Doe", "paul@luv2code.com");
	}
	
	public void readStudent(StudentDAO studentDAO){
		Student tempStudent = new Student("Daffy", "Duck", "daffy@luv2code.com");
		studentDAO.save(tempStudent);
		Student myStudent = studentDAO.findById(tempStudent.getId());
		SOP(myStudent);
	}
	
	public void queryForStudents(StudentDAO studentDAO){
		List<Student> students = studentDAO.findAll();
		
		for(Student tempStudent:students){
			System.out.println(tempStudent);
		}
	}
	
	private void updateStudent(studentDAO){
		int studentId = 1;
		Student myStudent = studentDAO.findById(studentId);
		myStudent.setFirstName("Scooby");
		studentDAO.update(myStudent);
	}
	private void deleteStudent(studentDAO){
		int studentId = 3;
		studentDAO.delete(studentId);
	}
}


=========================================================================================================================================================================================
CREATE DATABASE TABLES FROM JAVA CODE


JPA provides options to create database table with the help of JPA annotations. 
It is useful for development and testing. 

In application.properties
-----------------------------
spring.jpa.hibernate.ddl-auto=create

When we run the application, JPA will drom the table and create them based on the annotations provided on your POJO. Not recommended in Production.


@Entity
@Table(name="student") 1
public class Student {

	@Id
	
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	private int id;
	
	@Column(name="first_name")
	private String firstName;
	
	@Column(name="last_name")
	private String lastName;
	
	@Column(name="email")
	private String email;
	…
	// constructors, getters / setters
}





Hibernate will generate and execute this:-
-------------------------------------------------
create table student (id integer not null auto_increment,
email varchar(255), first_name varchar(255),
last_name varchar(255), primary key (id))


If we want to create table once and then keep data, use: update
spring.jpa.hibernate.ddl-auto=update































		
	
		
	
