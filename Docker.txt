One way of deploying microservices 
    containers 
Create docker image for each microservice.
Docker image contains everything a microservice needs to run:
    Application runtime (JDK or Python or NodeJs)
    Application Code 
    Dependencies 
You can run these docker containers the same way on any infrastructure
    Your local machine 
    Corporate data center 
    Cloud 

*********************************************
Step 1: Installing Docker - Docker - V2
*********************************************
To use docker in windows, Use Powershell

********************************************************************
Step 2: Your First Docker Usecase- Deploy a Spring Boot application
********************************************************************
docker run in28min/todo-rest-api-h2:1.0.0.RELEASE


****************************************************************************
Step 3: Docker Concepts - Registry, Repository, Tag, Image and Containers
****************************************************************************

docker run in28min/todo-rest-api-h2:1.0.0.RELEASE
When we run this command, an image is downloaded from 'hub.docker.com' . It is called docker registry. This registry contains 
many repositories. 
If you type do--
hub.docker.com/in28min/r/todo-rest-api-h2

Default Registry(hub.docker.com) > Repository (in28min/r/todo-rest-api-h2)  
                                   This repository contains different versions of the application. (You can see all the verions under tags)
                                   These versions are images

When we run 'docker run image_name', first it downloads the image and then run it. 
Image - A static templage - A set of Bytes 
Container - Running version of your image 
For the same image, you can have multiple containers runnning. 

When we hit the url in our browser 'http://localhost:5000/hello-world', We get an error (Ouch! Why did it happen?)
Stop the container by ctrl+c and type below command:-
docker run -p 5000:5000 in28min/todo-rest-api-h2:1.0.0.RELEASE          (Now it will run. what the fuck was that? )
What happens, by default when we run a container, it is part of something called by bridge network in docker. We can thik it like 
a internal docker network. 
So, in the above command, we are exposing container port (5000) to our host port(5000).
-p 5000:5000 ---> -p {HostPort}:{ContainerPort}


***************************************************
Step 4: Playing With docker images and containers 
***************************************************
We don't want to tie-up terminal with the lifecycle of the container. (We want to run docker container in the detached mode)
docker run -p 5000:5000 -d in28min/todo-rest-api-h2:1.0.0.RELEASE 
ec3c9cc073407ccd698baa4539e4b502f4f36fb9943bb4e67ccc0586c689ad7b    (You will get the container id only)

If you want logs--
docker logs container_id (You can enter initial four characters)     (Actually, It is 'docker container logs container_id')

If you want tailing the logs 
docker logs -f container_id 


Let's enter another url:: (Just for fun)
http://localhost:5000/jpa/users/in28minutes/todos 
And you can see in terminal, it is tailing the logs. (Yahoo!!!)
Press ctrl + C to stop tailing the logs. 

We want to see what are the containers that are running:- 
docker container ls 

We can run more than one container:-
docker run -p 5001:5000 -d in28min/todo-rest-api-h2:1.0.0.RELEASE 

Now, we have two instances of an image running. One at 5000 and another one at 5001.

If you want to see images. 
docker images

If you want to see all containers irrespective of their status:-
docker container ls -a 

If you want to stop docker container:-
docker container stop container_id 


**************************************************************************************
Step 5: Understanding Docker Architecture - Docker Client, Docker Docker Engine 
**************************************************************************************

Docker Architecture:
-------------------------
The place where we were running the commands in is docker client. 
When we type command in docker client, the command is sent out to docker daemon(docker engine) for execution.
Docker Deamon is responsible for maintaining local images, containers and pulling images from image registry 
or pushing locally generated images to image registry. 


(docker run command first download the image. If it is already downloaded, it will not download again)


*************************************
Step 6: Why is Docker popular? 
*************************************

*************************************
Step 7: Playing with Docker images  
*************************************
You can give tags as many as you want to your image. 
docker tag in28min/todo-rest-api-h2:1.0.0.RELEASE in28min/todo-rest-api-h2:latest

docker images 
You will see two images with same IMAGE_ID but different tags. 

docker pull mysql   (It will pull the imgae. It will pull the latest, but it is not always that 
                    it should pull latest version.It is just a tag)

>docker search mysql     (It will give the information whether it mysql is official image or not)

You can see the history of docker image-- 
>docker image history image_id 

You can inspect more into docker image-- 
>docker image inspect image_id 

To remote image from local 
>docker image remove Image_id 

To remove image forcefully--
>docker image remove -f Image_id


*****************************************
Step 8: Playing with Docker Containers   
*****************************************

To pause a running container 
>docker container pause container_id 

(If you do docker container stop and then use docker container run. It will run the new container with different container id (stop command will do graceful shutdow 
of container),while you can unpause the paused container)
>docker container unpause container_id 

You can inspect a docker container:-
>docker container inspect container_id 

You can remove all the stopped containers 
>docker container prune


When you 'docker container stop container_id', It does graceful shut-down of the container and takes 10 seconds for that. 
When you run--->
>docker container kill container_id 
It is stopped dead. (No graceful shutdown)

stop ==> SIGTERM ==> graceful shutdown 
kill ==> SIGKILL ==> immediately terminated the process 

>docker container run -p 5000:5000 --restart=always repository:tag 
Now, restart your docker desktop, It will start container again. 


*******************************************************
Step 9: Playing with Docker Commands: stats, system   
*******************************************************
>docker events 
Run this command in another terminal and see what happens in this ternminal when you run any docker command.

>docker top container_id (You will get lots of information of runnig container like uid, pid etc) 

>docker stats container_id 
It will give information like memory usage and cpu usage. 

While running a container we can limit memory and cpu usage. 
docker run -p 5001:5000 -d -m 512m --cpu-quota 5000 in28min/todo-rest-api-h2:1.0.0.latest
(-m 512m or -m 1G which tends to 512MB and 1GB respectively)
(For cpu quota, 
    100,000--> 100%
    5000--> 5%)

>docker system df 
It gives all the information that the docker deamon manages. 


****************************************************
Step 10: Introduction to Distribute Tracing
****************************************************
Now, we will try to run microservices using docker (We will create containers for most of the microservices 
and try and run them using docker). 
The first feature that we would explore is Distribute Tracing. 

Microservices is a complex chain. How do you debug problems? How do you trace request and identify a particular 
microservice where the problem is. And here, we go into the feature DistributeTracing. 

How does DistributedTracing work?
All the microservices will send all the information out to DistributeTracingServer and this Distribute Tracing Server 
would store everything to a database. This database could be in memory database or real database. In production, we use real database. 
Distributed Tracing Server will provide the interface which will allow us to trace the request across multiple microservices. 
We will use zipkin container as Distributed Tracing Server in this course.


****************************************************
Step 11: Launching Zipkin Container using Docker
****************************************************
 docker run -p 9411:9411 openzipkin/zipkin:2.23
 Zipkin runs on port 9411.
 http://localhost:9411/zipkin/ (You can access)

 In the next step, we will try to connect all the microservices to zipkin 

 ****************************************************************
Step 12 00: Getting started with Observability and OpenTelemetry
*****************************************************************

Monitoring vs Observability: Monitoring is reactive. Observability is proactive. 
    Monitoring is subset of observability. 

Observability: How well do we understand what's happening in a system? 
    Step 1: Gather data: metrics, logs or traces. (Monitoring)
    Step 2: Get intelligence: AI/Ops and anomaly detection. 

OpenTelemetry: Collection of tools, APIs, and SDKs to instrument, generate, collect, and export
telemetry data (metrics,logs and traces)
    All applications have metrics, logs and traces. 
        Why do we need a separate standard for each one of these. 
        OpenTelemetry: How about one standard for metrics, logs and traces? 
        Almost all cloud platforms provide support for OpenTelemetry today!

 ****************************************************************
Step 12 : Connecting Currency Exchange Microserve with Zipkin 
*****************************************************************

Each microservice will send tracing information to Distributed Tracing Server (Zipkin) and distributed tracing server 
would have stored all the information in a database and would provide a ui and you can query against the ui and find information
about the request which are executed.  


 **************************************************************************
Step 14 : Getting setup with Microservices for Creating Container Images  
***************************************************************************
 We just need maven plugin (Which is already present in our pom.xml file) to create image for our application. 

 Add configuration to add name for our docker image. 
 <plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <configuration>
        <image>
            <name>in28min/mmv3-${project.artifactId}:${project.version}</name>
        </image>
        <pullPolicy>IF_NOT_PRESENT</pullPolicy>
    </configuration>				
</plugin>

in28min is our docker_id, and all docker images will be created under in28min. If you don't have docker_id, you can 
create that one and write here that one. Or, I am using pre-existing docker_id in28min. 
mmv3-${project.artifactId}:${project.version} ---> This is a docker image. 

<pullPolicy> tag--> maven pulls lots of images from docker to facilitate the creation of docker image for our 
application. We are mentioning pullPolicy as IF_NOT_PRESENT, that means maven should pull images if they are 
not present. 

Now, stop all the spring boot applications as well as zipkin server. 

Maven Build:-
In goals
    spring-boot:build-image -DskipTests         (If this is the real project, we should not write -DskipTests ideally)
    