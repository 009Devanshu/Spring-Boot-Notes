One way of deploying microservices 
    containers 
Create docker image for each microservice.
Docker image contains everything a microservice needs to run:
    Application runtime (JDK or Python or NodeJs)
    Application Code 
    Dependencies 
You can run these docker containers the same way on any infrastructure
    Your local machine 
    Corporate data center 
    Cloud 

*********************************************
Step 1: Installing Docker - Docker - V2
*********************************************
To use docker in windows, Use Powershell

********************************************************************
Step 2: Your First Docker Usecase- Deploy a Spring Boot application
********************************************************************
docker run in28min/todo-rest-api-h2:1.0.0.RELEASE


****************************************************************************
Step 3: Docker Concepts - Registry, Repository, Tag, Image and Containers
****************************************************************************

docker run in28min/todo-rest-api-h2:1.0.0.RELEASE
When we run this command, an image is downloaded from 'hub.docker.com' . It is called docker registry. This registry contains 
many repositories. 
If you type do--
hub.docker.com/in28min/r/todo-rest-api-h2

Default Registry(hub.docker.com) > Repository (in28min/r/todo-rest-api-h2)  
                                   This repository contains different versions of the application. (You can see all the verions under tags)
                                   These versions are images

When we run 'docker run image_name', first it downloads the image and then run it. 
Image - A static templage - A set of Bytes 
Container - Running version of your image 
For the same image, you can have multiple containers runnning. 

When we hit the url in our browser 'http://localhost:5000/hello-world', We get an error (Ouch! Why did it happen?)
Stop the container by ctrl+c and type below command:-
docker run -p 5000:5000 in28min/todo-rest-api-h2:1.0.0.RELEASE          (Now it will run. what the fuck was that? )
What happens, by default when we run a container, it is part of something called by bridge network in docker. We can thik it like 
a internal docker network. 
So, in the above command, we are exposing container port (5000) to our host port(5000).
-p 5000:5000 ---> -p {HostPort}:{ContainerPort}


***************************************************
Step 4: Playing With docker images and containers 
***************************************************
We don't want to tie-up terminal with the lifecycle of the container. (We want to run docker container in the detached mode)
docker run -p 5000:5000 -d in28min/todo-rest-api-h2:1.0.0.RELEASE 
ec3c9cc073407ccd698baa4539e4b502f4f36fb9943bb4e67ccc0586c689ad7b    (You will get the container id only)

If you want logs--
docker logs container_id (You can enter initial four characters)

If you want tailing the logs 
docker logs -f container_id 


Let's enter another url:: (Just for fun)
http://localhost:5000/jpa/users/in28minutes/todos 
And you can see in terminal, it is tailing the logs. (Yahoo!!!)
Press ctrl + C to stop tailing the logs. 

We want to see what are the containers that are running:- 
docker container ls 

We can run more than one container:-
docker run -p 5001:5000 -d in28min/todo-rest-api-h2:1.0.0.RELEASE 

Now, we have two instances of an image running. One at 5000 and another one at 5001.

If you want to see images. 
docker images

If you want to see all containers irrespective of their status:-
docker container ls -a 

If you want to stop docker container:-
docker container stop container_id 




