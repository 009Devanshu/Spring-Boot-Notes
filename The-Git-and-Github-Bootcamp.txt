----------------------------------------
Configuring Your Git Name and Email
----------------------------------------

People would be able to know who did what when they will go through checkpoints. Configure Email as with the github account.
>git config --global user.name "Devanshu"
(>git config --global user.name ==> It will show the name if you have already configured the name)
We will do the same process for Email
>git config --global user.email "devg789123@gmail.com"

To override the previous name or email, just run the command again. It will override the previous ones.


-----------------------------------
Installing GitKraken
-----------------------------------
https://www.gitkraken.com/
Git Registration
Username: Devanshu
Email: devg789123@gmail.com
Password: deepthemazic



-------------------------
Navigation
-------------------------
When we open Git Bash, we are in Home directory and it is symbolized with ~
>ls 
It lists all the files and folders present in the current directory.

To open the current directory, 
>open .     (for mac)
>start .    (for windows)

ls shows all the folders and files present in current directory. If we want to know inside a particular folder in that directory
>ls <folder name>

We can also open a particular folder present in directory--
>open <folder name>     (for mac)
>start <folder name>    (for windows)

If a folder(y) is present inside a folder(x) which is present in the current directory and you want to see content present in folder y--
ls x/y



--------------------------------
pwd (Print Working directory)
--------------------------------
-------------------------------
cd (change directory)
-------------------------------
cd ..   (Go back one level)





-----------------------------------------------------------------------
Creating Files and Folders 
-----------------------------------------------------------------------
To Create File:
touch <file_name.extension_name>

We can create multiple files in one go: 
touch <file_name.extension_name> <file_name.extension_name>

To Create directory:
mkdir <folder_name>



---------------------------------------------------------
Deleting Files and Folders
---------------------------------------------------------
To Delete a file:
>rm <file_name> (This permanently deletes the file, not in recycle bin)
We can delete multiple files in one go 

To Delete a particular folder:
>rm -rf <folder_name>   (It is gone forever)

Note: ls -a (Shows all the files including hidden files)




-----------------------------------------------------------
git init and git status
-----------------------------------------------------------
git init initialize empty git repository or reinitialize an existing one. (create .git folder)
.git tracks all the history of repository.


-----------------------------------------------------------------------
A Common Early Git Mistake
-----------------------------------------------------------------------
When we do git init. Then git is going to watch everything in the currest directory as well as nested directory.
Suppose we have git repo MyFirstNovel

If we create another folder inside it, let's say Intro--
/Basics/MyFirstNovel (master)
>mkdir Intro
>cd Intro

/Basics/MyFirstNovel/Intro (master) (You can see that I did not initialize Intro, but it seems like git is tracking Intro directory also)
We can check git status

If we make another directory inside Intro, it will also be tracked.So, here is the warning--
warning: Do not initialize repo inside of a repo.
Before running git init, use git status to verify that you are not currently inside of a repo.
If we initialize inside directory again. In that case, it will be confusing and it would be like git tracking git.

Let's create a directory inside Basics and initialize that.

Conclusion: Make one repo per project.



-----------------------------------------------------------------------
The Committing Workflow Overview
-----------------------------------------------------------------------


The Basic Workflow:
----------------
Work On Stuff (Make new files, edit files, delete files etc)----->Add Changes (Group specific Changes together,in preparation of committing)---->Commit(Commit everything that was previously added)




-----------------------------------------------------------------------
Staging Changes with Git Add 
-----------------------------------------------------------------------
Let's say in our working directory, we have 7 files 
deleted team.html
modified about.html
modified about.css 
created navbar.html 
created navbar.css 
created navbar.js 
created logo.jpg

We can stage first three files together (git add team.html about.html about.css) and then commit them.
After that we can stage last four files (git add navbar.html navbar.css navbar.js logo.jpg) and then commit them.






----------------------------------------------------------
Finally, the git commit command
----------------------------------------------------------
Running 'git commit' will commit all staged changes. It also opens a text editor and prompts you for a commit message. So, write message along with 'git commit' 
>git commit -m "Your_message"



----------------------------------------------------------
The Git Log Command (And more committing)
----------------------------------------------------------
>git log 
It returns log of commits 

Note: git add . (stages all changes at once)



-----------------------------------------------------------
Git Documentation
----------------------------------------------------------
It has reference manual. Their book is great.


---------------------------------------------------
Keep Your commits Atomic
---------------------------------------------------
When possible, a commit should encompass a single feature, change or fix. In other words, try to keep each commit focussed on a single thing.
This makes it much easier to undo or rollback changes later on. It also makes your code or project easier to review.


---------------------------------------------------
Commit messages Present or Past
---------------------------------------------------
Git doc recommmends to use Imperative sentence. Someone said that people should use Imperative sentence because git sometimes generates its own message. But, the 
community is split on this debate.


--------------------------------------------------
A closer look at Git log command 
--------------------------------------------------
>git log --abbrev-commit        (We are getting small piece of hashes)
>git log --oneline

(You can go for more. Git Documentation >> reference manual >> log >> formatting_commit)



-----------------------------------------------------
Committing with a Gui
-----------------------------------------------------
First Click on Stage, Write commit and click the button. (Just Simple)



-------------------------------------------------------
Amending Commits 
-------------------------------------------------------
Suppose you just made a commit and then realized you forgot to include a file! or maybe you made a typo in the commit message that you want to correct. 
Rather than making a brand new separate commit. You can "redo" the previous commit using the --amend 

>git commit -m "some commit"
>git add forgotten_file
>git commit --amend

It will open your editor (Visual Code), where you can change your message. If not, it will be committed with previous message with new file.


-------------------------------------------
Ignoring Files 
-------------------------------------------
We can tell git which files and directories to ignore in a given repository, using a .gitignore file. This is useful for files you know you never want to commit, includi:
-Secrets, Api keys, credentials etc
-Operating system files (.DS_Store on Mac)
-Log files 
-Dependencies and packages

Create a file called .gitignore in the root of a repository. Inside the file, we can write patterns to tell Git which files and folders to ignore:
-.DS_Store will ignore files named .DS_Store
-folder_name/ will ignore entire directory
-*.log will ignore any files with the .log extension 





---------------------------------------------------
Section 6: Working With Branches
---------------------------------------------------



Note: Each commit has hashcode, reference to its parent commit and a message associated it.


------------------------------------
The Master Branch (Or is it Main?)
------------------------------------
The Master Branch: In git, we are always working on a branch. The default branch name is master. It doesn't do anything special or have fancy powers. It's just like any 
other branch.

Many people designate the master branch as their "source of truth" or the "official branch" for their codebase, but that is left to you decide.
From Git's perspective, the master branch is just like any other branch. It does not have to hold the "master copy" of your project.
    


------------------------------------
What on Earth is Head?
------------------------------------
When we write 'git log', we can see Head -> Master
HEAD is simply a pointer that refers to the current "location" in your repository. It is a reference to a branch pointer and a branch pointer is where a branch currently is.
So far, HEAD always points to the latest commit you made on the master branch, but soon we will see that we can move around and HEAD will change. 
If we make new branch, if we see, by default HEAD would be at the latest commit of that branch.




------------------------------------
Viewing Branches
------------------------------------
>git branch


------------------------------------
Creating and Switching Branches
------------------------------------
>git branch <branch-name>
Make a new branch based on the current HEAD (Where is HEAD referencing to a branch pointer of current branch).
This just creates the branch from that pointer and when you do git log in new branch, you can see HEAD referencing to commit as was referencing to in previous branch. It does not switch you to that branch (the HEAD says the same)

Once you have created a new branch, use 'git switch <branch-name>' to switch to it. 


--------------------------------------------------
Additional Option: Git checkout vs Git switch
--------------------------------------------------
git checkout does some additinal tasks. Nothing special. git switch is much simpler. That's it.


>git checkout <branch_name>

>git checkout -b <branch_name> (Make a branch and switch to it)

Use git switch with the -c flag to create a new branch AND switch to it all in one go. 
-c as short to create 

>git switch -c <branch_name>



--------------------------------------------------
Switching Branches with unstaged changes?
--------------------------------------------------
Suppose there is a master branch, we create two branches one is pizza and second one is popsickle. In master branch, we create a file songs.txt and add some songs and commit them. Now, we switch to branch pizza and add some songs, but we don't stage and commit them and try to switch to popsickle branch, then git will not  allow to do that (Atleast in one of the situations that I see)--

$ git switch emptyplaylist
error: Your local changes to the following files would be overwritten by checkout:
        playlist.txt
Please commit your changes or stash them before you switch branches.
Aborting

But If we add a new file in pizza, then switch to popsickle, git allow to do that because It is a new file. 

---------------------------------------------------
Deleting & Renaming Branches
---------------------------------------------------

-D is short for --delete --force 
--force allow deleting the branch irrespective of its merge status.
Even if you want to delete a branch, you will have move out from that branch. You can not delete the branch in which you are already present.

If we run this command:
>git branch -d deleteMe
$ git branch -d deleteMe
error: The branch 'deleteMe' is not fully merged.
If you are sure you want to delete it, run 'git branch -D deleteMe'.

So, 
>git branch -D deleteMe (It will work)

Renaming: 
To rename a branch, we will have to go into that branch.
>git branch -m 200s


Note: To add and commit in one go. 
>git commit -a -m "la CASA the Papel"
(First It will add all the files and then commit)




-------------------------------------------------------
An Introduction To Merging 
-------------------------------------------------------
Often we want to incorporate changes from one branch to another. We can do this using the git merge command.


- We merge branches, not specific commits.
- We always merge to current HEAD branch.

To merge, follow these basic steps: 
1. Switch to or checkout the branch you want to merge the changes into (the receiving branch)
2. Use the git merge command to merge changes from a specific branch into the current branch. 

Example: to merge the bugfix branch into master 
>git switch master 
>git merge bugfix

Demonstration:

Switch to the branch 
987fac------------->235ff------------------>92faa------------------>2456
                     ^                                                ^
                     .                                                .
                     .                                                .
                     .                                                .
                   (master<-----HEAD)                              (bugfix)


After merge



                                                             (master<-----HEAD)
                                                                     .
                                                                     .
                                                                     .
                                                                     ↓
987fac------------->235ff------------------>92faa------------------>2456
                                                                     ^
                                                                     .
                                                                     .
                                                                     .
                                                                  (bugfix)



Note: To reach to the end of git log content, press downarrow.






------------------------------------------------------
Performing a fast forward merge
------------------------------------------------------

Note: 
Try to understand this logic--->
commit 9826134fbdb068cc6d376365dd192a43b02101ab (HEAD -> 200s)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:06:36 2023 +0530

    a+b=c in playlist.txt

commit 732371378e965e588787678f5428025bdcec3469
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:05:38 2023 +0530

    modify two files

commit 7faa637e083d23a4bc5480a5c9d657ef81293d52 (emptyplaylist)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:03:19 2023 +0530

    modify playlist.txt

commit 0f783a3738683b3d0425a649f534056df1c2dff5 (sideradio, master)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:01:49 2023 +0530

    modify chickens.txt

commit dc1222eff204f95d6a910e570f1285d347b6309e
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:01:01 2023 +0530

    add two files






>git switch master
>git merge emptyplaylist

commit 7faa637e083d23a4bc5480a5c9d657ef81293d52 (HEAD -> master, emptyplaylist)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:03:19 2023 +0530

    modify playlist.txt

commit 0f783a3738683b3d0425a649f534056df1c2dff5 (sideradio)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:01:49 2023 +0530

    modify chickens.txt

commit dc1222eff204f95d6a910e570f1285d347b6309e
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:01:01 2023 +0530

    add two files







You can see whole log: 
commit 9826134fbdb068cc6d376365dd192a43b02101ab (HEAD -> 200s)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:06:36 2023 +0530

    a+b=c in playlist.txt

commit 732371378e965e588787678f5428025bdcec3469
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:05:38 2023 +0530

    modify two files

commit 7faa637e083d23a4bc5480a5c9d657ef81293d52 (master, emptyplaylist)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:03:19 2023 +0530

    modify playlist.txt

commit 0f783a3738683b3d0425a649f534056df1c2dff5 (sideradio)
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:01:49 2023 +0530

    modify chickens.txt

commit dc1222eff204f95d6a910e570f1285d347b6309e
Author: Devanshu <devg789123@gmail.com>
Date:   Sat Oct 28 10:01:01 2023 +0530

    add two files


(You can see Fast-forward in the message after merging)




---------------------------------
Generating Merge Commits 
---------------------------------
You are working for a few hours and you want to merge it back in to the master branch. My teammate has done work since i created my branch. So, there is a commit over master branch or ten commits that i don't have on my branch but it is on master. So, when i try to merge, it is no longer a fast forward. 
We use the same command but git may not be able to do it automatically for us. It depends upon the particulars of our commits (may be there is a conflicting information).
For example, what happens if on the master branch my partner edited line 59 of a file and on the bugfix branch i edited same line to be something else. Which one wins when there is a conflict. (Well we will address this thing in the next video). For now, we are going to show where we don't arrive at conflict and  git is able to make the merge for us automatically. So, what happens in these scenarios when it is not a fast-forward merge. Git performs a "merge commit". We end up with a new commit on the master branch. Git will prompt you for a message (to override git generated message).
 This new merge commit actually two different parent commits. (Remember: Every commit has parent) (See slides for more visualization)

Question: Give an example of merge which is not fast-forward merge but it does not do any conflict.
We create a new branch from master branch. We do some changes in the existing file and commit. On the other hand, another person in master branch 
create another file and commit. When i switch to master branch and merge. It is not a fast-forward merge. 


----------------------------------
Oh No! Merge Conflicts!
----------------------------------
Conflicting Changes:
1)On one branch, somebody modified a file and on the second branch that we are merging, somebody deleted the same file.
2)My teammate edited line 77 of file on on the branch and I edited same line of the same file in different branch. Now, git will not automatically allow to merge these branches. We have to manually resolve them. 



How to fix this: 
>Conflict (content): Merge conflict in blah.txt 
Automatic merge failed; fix conflicts and then commit the result.

Whenever you encounter merge conflicts, follow these steps to resolve them: 
1. Open up the file(s) with merge conflict.
2. Edit the file(s) to remove conflicts. Decide which branch's content you want to keep in each conflict. Or keep the content from both. 
3. Remove the conflict "markers" in the document. 
4. Add your changes and then make a commit!

(Particular line number par agar content different h, to conflict issue ayega)


------------------------------------
Resolving Merge Conflicts 
------------------------------------

---------------------------------------
Using VSCode To resolve conflictts
---------------------------------------

Note: Use "code ." to open file.



----------------------------------------------------------------------------------------------------------------------------------------


**************************************************
Section 8: Comparing Changes with Git Diff 
**************************************************

------------------------------------
Introducing The Git Diff Command
------------------------------------

We can use Git Diff command to view changes between commits, branches, files, our working directory and more!
We often use Git Diff along alongside commands like git status and git log, to get a better picture of a repository and how it has changed 
over time.

Suppose you have done a lots of changes and you don't know exactly what changes did you make (It is before staging). Here comes the git diff. 
git diff lists all the changes in our working directory that are not staged for the next commit.

>git diff 
Comparing Staging area and Working directory.



----------------------------------------
A guide to Reading Diffs 
----------------------------------------

Compared Files:
For each comparison, Git explains which file it is comparing. Usually, this is two versions of the same file. 
Git also declares one file as "A" and the other as "B".
diff --git a/rainbow.txt b/rainbow.txt

File Metadata 
You really don't need to care about the file metadata. The first two numbers are the hashes of the two files being compared. The last 
number is an internal file mode identifier.
index 72d1d5a...f2c8117 100644

Markers:
File A and File B are each assigned a symbol.
    -File A gets a minus sign (-)
    -File B gets a plus sign (+)
--- a/rainbow.txt 
+++ b/rainbow.txt 


Chunks:
A diff won't show the entire contents of a file, but instead only shows portions or Chunks that were modified.
A chunk also includes  some unchanged lines before and after a change to provide some context.

@@ -3,4 +3,5 @@ orange          (This is called chunk header)
yellow 
green 
blue 
-purple
+indigo 
+violet


-3,4 is from file a and +3,4 is from file b. 
-3 and +3 shows chank is starting from line number 3 of the files a and b respectively.
Chunk Header:
Fron file a, 4 lines are extracted starting from line 3. 
From file b, 5 lines are extracted starting from line 3.  (Go to pdf to visualize more)




----------------------------------------
Viewing Unstaged Changes 
----------------------------------------

Withour addtional options, git diff lists all the changes in our working directory that are not staged for the next commit. 
>git diff 
Comparing working directory and staging area. 








++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
git diff HEAd lists all changes (staged as well as unstaged) in the working directory since your last commit. 
>git diff HEAD 


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


----------------------------------------------
Viewing Staged Changes 
----------------------------------------------

git diff --staged or --cached will list the changes between the staging area and our last commit. 
"Show me what will be included in my commit if i run git commit now.
>git diff --staged 
>git diff --cached 




----------------------------------------------
Diffing specific files
----------------------------------------------

Diffing specific files :
We can view the changes within a specific file by providing git diff with a file name
>git diff HEAD [filename]
>git diff --staged [filename]


----------------------------------------------
Comparing Changes across Branches
----------------------------------------------

Comparing Branches :
git diff branch1..branch2 will list the changes between the tips of branch1 and branch2
>git diff branch1..branch2 



----------------------------------------------
Comparing Changes across Commits
----------------------------------------------



Comparing commits :
To compare two commits, provide git diff with the commit hashes of the commits in question.
>git diff commit1..commit2




----------------------------------------------
Visualizing Diffs with GUI
----------------------------------------------


----------------
Exercise:
---------------
It is one of the question from exercise to to understand git diff between current head and previous head--
Question: Switch over to the current branch if you are not currently on it. Run a diff to compare the current HEAD to the previous commit (you could use the commit hash or reference HEAD's parent commit)
Answer: 
>git diff HEAD HEAD~1


-----------------------------------------------------------------------------------------------------------------------


****************************************
Section 9: The INS and OUTS of Stashing
****************************************

-------------------------------
Why we need git stash?
-------------------------------
I am on master. I make some commits and then make a new branch and  switch over to that branch(It is called puppy). And I do some more work over here and then I have some uncommitted work on this puppy (Meaning we did not stage changes for commit). What happens when I switch back to master? 
There are two options: 
1. My changes come with me to the destination branch. 
2. Git won't let me switch if it detects potential conflicts.(It will show a message as we did previously)


Demonstration for first option--
1. We create Stashing folder, declared it as a repository. I am on master branch. I made two files app.css and index.html and wrote some code in index.html--
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello!</title>
    <link href="app.css" rel="stylesheet">
</head>
<body>
    <h1>Hello World!!</h1>
    <p1>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia facilis consequatur aperiam, beatae reprehenderit maxime tenetur et deleniti dolores! Aut repellat officiis numquam neque nam nostrum veniam qui soluta voluptate.</p1>
</body>
</html>

2. Made a new branch purple and switch to it. I add some code in app.css--
h1{
    color: purple;
}
body{
    background-color: lavender;
}

But, i did not staged this change in app.css for commit. If I git log in purple branch. 

commit cd991bed40df9a1bf2e18b886cd9aade1aef96d8 (HEAD -> purple, master)
Author: Devanshu <devg789123@gmail.com>
Date:   Mon Oct 30 18:50:22 2023 +0530

    create index.html and app.css

Now, I switched to master branch and checked git status: 
it will show unstaged change that we did in purple branch--
..
..
 modified:   app.css
..
..



Demonstration for second scenario:
1. I am on master branch. Create another branch goodbye. In master branch, I made some changes in index.html and commit them--
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello!!!!!!!!!!!!!!</title>
    <link href="app.css" rel="stylesheet">
</head>
<body>
    <h1>Hello World!!!!!!!!!!!!!!!!!!</h1>
    <p1>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia facilis consequatur aperiam, beatae reprehenderit maxime tenetur et deleniti dolores! Aut repellat officiis numquam neque nam nostrum veniam qui soluta voluptate.</p1>
</body>
</html>

2.
Now, i switch to purple branch I made some changes in index.html and also added code in app.css--

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goodbye!</title>
    <link href="app.css" rel="stylesheet">
</head>
<body>
    <h1>Goodbye World!!</h1>
    <p1>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia facilis consequatur aperiam, beatae reprehenderit maxime tenetur et deleniti dolores! Aut repellat officiis numquam neque nam nostrum veniam qui soluta voluptate.</p1>
</body>
</html>


I am not staging them for commit. Now, If I want to switch to master branch, git will not allow to do that due to conflicts--

$ git switch master
error: Your local changes to the following files would be overwritten by checkout:
        index.html
Please commit your changes or stash them before you switch branches.
Aborting

(Oh boy! I want to switch, but how can I do that. That's what we gonna learn in the next video)


------------------------------------------
Stashing Basics: Git Stash save and pop
------------------------------------------

Git provides an easy way of stashing these uncommitted changes so that we can return to them later, without having to make unnecessary commits.

git stash is super useful command that helps you save changes that you are not yet ready to commit. You can stash changes and then come back to them later.
Running git stash will take all uncommitted changes (staged and unstaged) and stash them, reverting the changes in your working copy.
>git stash 
You can also use git stash save instead

Use git stash pop to remove the most recently stashed changes in your stash and re-apply them to your working copy.
>git stash pop

------------------------------
Practicing with Git Stash
------------------------------

>git stash
Saved working directory and index state WIP on goodbye: 94eklj create index.html and app.css
(Here, index state is referred to staged state)

Now, if we run git status, we can see --  
$ git status
On branch goodbye
nothing to commit, working tree clean

We can see the files and any change is removed. (revert back). Now, we can switch to any branch and do whatever we want and after that we can switch to goodbye branch and run :
> git stash pop


---------------------------------------
git stash apply
---------------------------------------
You can use git stash apply to apply whatever is stashed away, without removing it from the stash. This can 
be useful if you want to apply stashed changes to multiple branches. It will take whatever in the stash and apply it in the same way that pop does. Except, with apply the stash 
stays in the stash. In other words, the changes are still in the stash and we can apply them in multiple places versus with pop changes are removed from the stash after they 
are applied. 

Demonstration:
1. I am on master branch. I create another branch goodbye. I come back to my master branch and  in master branch, I  made some changes in index.html and commit them. 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello!!!!!!!!!!!!!!</title>
    <link href="app.css" rel="stylesheet">
</head>
<body>
    <h1>Hello World!!!!!!!!!!!!!!!!!!</h1>
    <p1>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia facilis consequatur aperiam, beatae reprehenderit maxime tenetur et deleniti dolores! Aut repellat officiis numquam neque nam nostrum veniam qui soluta voluptate.</p1>
</body>
</html>

Now, our goodbye branch does not have that commit --
2.
Now, i switch to purple branch I made some changes in index.html and also added code in app.css--

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goodbye!</title>
    <link href="app.css" rel="stylesheet">
</head>
<body>
    <h1>Goodbye World!!</h1>
    <p1>Lorem ipsum dolor sit amet consectetur adipisicing elit. Quia facilis consequatur aperiam, beatae reprehenderit maxime tenetur et deleniti dolores! Aut repellat officiis numquam neque nam nostrum veniam qui soluta voluptate.</p1>
</body>
</html>


h1{
    color: purple;
}
body{
    background-color: lavender;
}


I am not staging them for commit. Now, If I want to switch to master branch, git will not allow to do that due to conflicts--

$ git switch master
error: Your local changes to the following files would be overwritten by checkout:
        index.html
Please commit your changes or stash them before you switch branches.
Aborting


I can use git stash apply, now changes will be in stash. But those changes can be apply in other branches as well without popping up them in the current branch (So, no chance of conflicting while switching to other 
branch). 

Now, go to master branch and >git stash apply. Come back to goodbye branch and you can reapply them using either >git stash apply or >git stash pop.




-----------------------------------------
Working with multiple stashes
----------------------------------------
You can add multiple stashes onto the stack of stashes. They will all be stashed in the order you added them.
>git stash
    do some other stuff...
>git stash 
    do some other stuff... 
>git stash 



We can view whatever is in the stash 
>git stash list
stash@{0}: WIP on rainbow: 810da1f remove background color
stash@{1}: WIP on rainbow: 810da1f remove background color
stash@{2}: WIP on rainbow: 810da1f remove background color


Applying specific stashes:
git assumes you want to apply the most recent stash when you run git stash apply, but you can also specify a particular stash like 
>git stash apply stash@{2}




-------------------------------------------
Dropping And Clearing The Stash 
-------------------------------------------
To delete a particular stash, you can use 
>git stash drop <stash-id>

Note: If you are using >git stash pop, you are removing the most recent stash.
      If you are using >git stash apply <stash-id>, you are not removing that stash. 


Clearing the Stash 
>git stash clear 

-------------------------------------------------------------------------------------------------------------------------------------------------------------

*****************************************************************
Section 10: Undoing Changes and Time Travelling
*****************************************************************

-------------------------------------
Checking Out Old Commits
-------------------------------------

We can use git checkout commit <commit-hash> to view a previous commit. Remember, you can use the git log command to view commit hashes. We just need the first 7 digits of a commit hash. 

>git checkout <commit-hash>

We get this wierd message--
You are in 'detached HEAD' state and blah blah blah.....

Usually, HEAD points to a specific branch reference rather than a particuler commit. 

How it works--
-HEAD is a pointer to the current branch reference
-The branch reference is a pointer to the last commit made on a particular branch.

When we make a new commit, the branch reference is updated to reflect the new commit. The HEAD remains the same, because it's pointing at the branch reference.

If we switch to the bugfix branch, HEAD is now pointing at the bugfix reference.

So, this is all to say that HEAD Usually refers to a branch NOT a specific commit.

When we checkout a particular commit, HEAD points at that commit rather than at the branch pointer.
(HEAD is detached now)


---------------------------------------
Re-Attaching Our Detached HEAD!
---------------------------------------

Detached HEAD 
Don't panic when this happens! It's not a bad thing
You have a couple options:
1. Stay in detached HEAD to examine the contents of the old commit. Poke around, view the files, etc.
2. Leave and go back to Whenever you were before - reattach the HEAD
>git switch <branch-name>
3. Create a new branch and switch to it. You can now make and save changes, since HEAD is no longer detached.


------------------------------------------
referencing Commits Relative to HEAD
------------------------------------------
HEAD~1 refers to the commit before HEAD (parent)
HEAD~2 refers to 2 commits before HEAD (grandparent)

>git checkout HEAD~1
If you want to go back from here further now, then again--
>git checkout HEAD~1

Suppose, you just forgot your last branch where  you were present after checkout to a commit, you can switch to that branch without knowing branch name--
>git switch -


---------------------------------------
Discarding Changes With Git Checkout 
----------------------------------------
Suppose you have made some changes to a file but don't want to keep them (Don't want to stage and commit them). To revert the file back to whatever it looked like when you last committed, you can use:
>git checkout HEAD <filename> to discard any changes in that file
So, instead of manually removing stuff from files, we can do this.

Another Option--
Here's another shorter version to revert a file....
Rather than typing HEAD, you can substiture -- followed by the file(s) you want to restore.
>git checkout -- <file>




------------------------------------------------
Un-modifying with Git Restore 
------------------------------------------------

Un-Modifying files with Restore --
Suppose you've made some changes to a file since your last commit. you have saved the file but then realize you definitely do NOT want those changes anymore!
To restore the file to the contents in the HEAD, use 
>git restore <file-name>
Note: The above command is not "undoable" if you have uncommitted changes in the file, they will be lost!



This command is same as we did earliear --
>git checkout HEAD <file-name> or >git checkout -- <file-name>


git restore <file-name> restores using HEAD as the default source, but we can change that using the --source option.
For example, git restore --source HEAD~1 home.html will restore the contents of home.html to its state from the commit prior to HEAD. You can also use a particular commit hash as the source. 
>git restore --source HEAD~1 app.js



Note:
Suppose, you do >git restore --source HEAD~2 dog.txt 
If you git log, you will see HEAD is not detached. And if you do git status. You can see changes are not staged.That means if you stage and commit at this time, a new commit will be created ahead of HEAD and HEAD will move forward. Instead of committing if you do, git restore dog.txt, You will back to restore the dog.txt at the last commit.


In Case of >git checkout HEAD~2 dog.txt, changes are staged but not committed. HEAD is also not detached (Now, you can imagine everything). (If you do git restore dog.
txt, nothing will happen because >git restore undo changes which are not staged) 
Note: If you do >git checkout HEAD~2, HEAD is detached.



-----------------------------------------
Un-Staging Changes with Git Restore
-----------------------------------------

If you have accidentally added a file to your staging area with git add you don't wish to include it in the next commit, you can use git restore to remove it from staging. 
Use the --staged option like this:
>git restore --staged app.js



-----------------------------------
Undoing Commits With Git Reset 
-----------------------------------
Suppose you have just made a couple of commits on the master branch, but you actually meant to make them on a separate branch instead. To undo those commits, you can use git reset. 
git reset <commit-hash> will reset the repo back to a specific commit. The commits are gone. 
>git reset <commit-hash>

Suppose you made change and made a commit. You made another change and another commit. After that you realized you should not have to do those commits. You reset commits-
>git reset <commit-hash 2 steps back>
But, if you see in the file, you can see those changes (Ofcourse they are not staged). So, 
git reset <commit-hash> is plain reset.
Note: You can undo changes using >git restore <file-name>
Another way to undo those changes in master branch, create a new branch and switch to it. Those changes will come to new branch. You can add and commit those changes. When you switch to master branch, you can see those changes are gone.


Reset --hard 
If you want to undo both the commits AND the actual changes in your files, you can use the --hard option.
for example, git reset --hard HEAD~1 will delete the last commit and associated changes.
>git reset --hard <commit> 


---------------------------------------
Reverting Commits With...Git Revert 
---------------------------------------
git revert is similar to git reset in that they both "undo" changes, but they accoplish it in different ways. 
git reset actually moves the branch pointer backwards, eliminating commits. 
git revert instead creates a brand new commit and in that new commit it undoes the changes from earlier commit, you will be prompted to enter a commit message.
>git revert <commit-hash>

(Go for pdf for more clarity if you want)























































































































