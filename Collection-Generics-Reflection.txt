Compile time errors are easy to be detectable as the application will not be compiled. 
Runtime errors are more problematic.
So, prefer compile time errors to Runtime errors.

Why to use generics?
1)It makes most of the errors and bugs to be detectable at compile time and not at Runtime.
    Stronger type-check at compile time. If our code violates type safety then the compiler warns us.

2)generics enable types (classes and interfaces) to be parameters when defining other classes, interfaces and methods. We can reuse the same code with different inputs.
public void draw(Car car)
    Here, we are passing Car as a parameter.
public void draw(T t)
    We are using generic type.

3)We can eliminate type casting
    
    List list = new ArrayList<>();
    String name = (String)list.get(0); We are doing type casting

    List<String> list = new ArrayList<>();
    String name =  list.get(0);


===========================================================================================================

Problem Illustration

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void main(String[] args) {
		add(10,28);
	}
}

Here, we are dealing with only int type parameters.

What if we want to pass double type arguments. Then, we will have to overload the add method--

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void add(double num1, double num2) {
		double result = num1+num2;
		System.out.println("The result is: "+result);
	}
	public static void main(String[] args) {
		add(10.3,28.9);
	}
}

so, for  different types of arguments, we have to perform overloading. We can handle this situation using generics

***************************************************************

Another Problem Illustration--->

class Store{
	private Object item;

	public Object getItem() {
		return item;
	}

	public void setItem(Object item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store theStore = new Store();
		theStore.setItem(45);
		Integer result =  (Integer)theStore.getItem();
		System.out.println(result);
	}
}


What is the problem with this code?
1: theStore.setItem(45);
    We can change value from int (45) to double (45.5), compiler will not give any error. We will get error at run-time only.
2: We are type-casting.

**************************************************************************************************


*************************************************************************************************

class Store <T>{
	private T item;

	public T getItem() {
		return item;
	}

	public void setItem(T item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store<String> theStore = new Store<>();
		theStore.setItem("Hello World");
		String result =  theStore.getItem();
		System.out.println(result);
	}
}

Now, we are using generics. 
Suppose we want to pass String type.
    Store<String> theStore = new Store<>();
    Now, compiler will warn if we pass any other value except String in setItem() method. (Compile-time error)
We don't need to type cast 
    String result =  theStore.getItem();

In this programme, if we write Store theStore = new Store(); Store is a raw type. Now, it is not type safe and you will also have to do type-casting.
In case of collection, 
List list = new ArrayList();	(Compiler will warn us that you are using raw type)
list.add(20);					(Hey, we are not doing type-casting? Yes, In case of collection objects, we don't need to type caste despite the fact that we are using raw type of List.)


<>  This is diamond operator.

****************************************************************************************************************************

****************************************************************************************************************************

We have seen generics with a single generic type. We can use multiple generic types.

class Hashtable<K,V>{
	private K key;
	private V value;
	public Hashtable(K key, V value) {
		super();
		this.key = key;
		this.value = value;
	}
	@Override
	public String toString() {
		return "Hashtable [key=" + key + ", value=" + value + "]";
	}
	
	
}
public class App {

	
	public static void main(String[] args) {
		Hashtable<String,Integer> hashtable = new Hashtable<>("Hello",12);
		System.out.println(hashtable);
	}
}

Here, Hashtable is a custom class. Not the one from Collection framework.



********************************************************************************************************
Generic Methods 
********************************************************************************************************
We have seen generic types, now we will see generic methods--

public class GenericMethod {

	public <T> void showItem(T item) {
		System.out.println("The item is: "+item.toString());
	}
}



/**If we write 
public  void showItem(T item) {
		System.out.println("The item is: "+item.toString());
}

It will give compile time error in the parameter. We will have to use wildcard before return type.
public <T> void showItem(T item) {
		System.out.println("The item is: "+item.toString());
}**/


In Main application --
GenericMethod method = new GenericMethod();
method.showItem(whatever type of value you can pass);
Ex1- method.showItem(35);
Output- The item is 35
Ex2- method.showItem("Hello World");
Output- The item is Hello World.


We can also return Generic type.
public <T> T showItem(T item){
	System.out.println("The item is: "+item.toString());
	return T;
}



********************************************************************************************************
Generic Methods II 
********************************************************************************************************
Other Demostrations --

public <T,V> void printItems(T t, V v) {
		System.out.println(t.toString());
		System.out.println(v.toString());
}
	



public <T> void showItems(T[] items) {
	for(T t: items) 
		System.out.println(t);
	
}

In Main method--
Integer[] items = {10,20,30,40};			(We can not use int[] type array or any primitive type array)
method.showItems(items);


********************************************************************************************************
Exercise
********************************************************************************************************

Let's implement a generic method that checks 2 parameters share the same value or not!

For example:
checkEquality(12, 8) returns false
checkEquality(10.5, 10.5) returns true
checkEquality("Joe", "Joe") returns true


public class Exercise {

    // implement the checkEquality() method that takes 2 values as input parameters and it returns
    // a boolean value whether the values are mathcing or not
    public <T,V> boolean checkEquality(T t, V v){
        return t.equals(v);
    }
    public static void main(String args[]){
        Exercise ex = new Exercise();
        boolean result =  ex.checkEquality(100,100);
        System.out.println(result);
    }
}



********************************************************************************************************
Section 4: Bounded Type Parameters
Bounded type parameters
********************************************************************************************************

Sometimes we want to restrict the types that can be used as type arguments in a parameterized type.
A method that operates on numbers(integers, floats or doubles) might only want to accept instances of the Number class or its subclasses.

Bounded types allow you to invoke methods defined in the bounds.
public class App {

	public static <T extends Comparable<T>> T calculateMin(T num1,T num2) {
		if(num1.compareTo(num2)<0) {						//We are able to invoke method defined in Comparable interface.
			return num1;
		}
		return num2;
	}
	public static void main(String[] args) {
		System.out.println(calculateMin("Hello","Anvesh"));
		System.out.println(calculateMin('k','a'));
		System.out.println(calculateMin(100,90));
	}
}


-------------------------------------------------------------
Another Demostration:
class Person implements Comparable<Person>{
	
	private int age;
	private String name;
	
	public Person(String name,int age) {
		this.age = age;
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public int compareTo(Person otherPerson) {
		return Integer.compare(age, otherPerson.getAge());
	}
	@Override
	public String toString() {
		return "Person [age=" + age + ", name=" + name + "]";
	}
	
}

public class App {

	public static <T extends Comparable<T>> T calculateMin(T num1,T num2) {
		if(num1.compareTo(num2)<0) {
			return num1;
		}
		return num2;
	}
	public static void main(String[] args) {
		System.out.println(calculateMin(new Person("Kevin",48),new Person("Henry",78)));
	}
}


-----------------------------------------------------------------------------------------------------------------------------------

***************************************
Section 5: Type Inference 
***************************************

What is Type Inference? 
Answer: It is the ability of compiler to determine the exact type that works with all the arguments.

		public class App {
			public static <T> void getData(T t1, T t2) {
				System.out.println(t1);;
			}
			public static void main(String[] args) {
				getData("Hello",new ArrayList<>());
			}
		}

		
		The above and below examples work fine.
		Here, String and ArrayList both implements Serializable. So, in 'public static <T> void get....', T is of Serializable type.

		public class App {
			public static <T> T getData(T t1, T t2) {
				return t1;
			}
			public static void main(String[] args) {
				Serializable s = getData("Hello",new ArrayList<>());
			}
	
		}





Because of the type inference, we can use class instantiation like this--
List<String> list = new ArrayList<>();



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class Bucket<T>{
	private T item;
	
	public T getItem() {
		return item;
	}
	public void setItem(T item) {
		this.item = item;
	}
}
public class App {
	
	public static <T> void addStore(T t, List<Bucket<T>> list) {
		Bucket<T> bucket = new Bucket<>();
		bucket.setItem(t);
		list.add(bucket);
		System.out.println(t.toString()+" has been added to the bucket");
	}
	
	public static void main(String[] args) {
		List<Bucket<String>> list = new ArrayList<>();
		App.addStore("Adam", list); //Java Compiler is going to determine the type of T (which is String here)
								//first argument is of type String and second argument is of type List of bucket of String
								//compiler will determine the type of T (in public static <T> void...) to be String.
		//type witness
		App.<String>addStore("Dani Daniels",list);
	}
	
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Another example of Type Inference
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

public class App {
	
	public static <T> List<T> show(List<T> list, T t1, T t2){
		list.add(t1);
		list.add(t2);
		return list;
	}
	
	public static void main(String[] args) {
		List<String> list = show(new ArrayList<>(),"Hello","Sunny");
		System.out.println(list);
	}
	
}
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

============================================================================================================================================

************************************************
Section 6: Wildcards 
************************************************

Integer is a subtype of Number.
List<Integer> is not a subtype of List<Number> despite the fact that Integer is a Number.
This is why we need Wildcards.


public void print(Collection<Object> c)
{
	for(Object o:c)
		System.out.println(o);
}
It will not work fine if we pass List<Integer> or List<String>.
This is why we need to consider Wildcards -  the supertype of all kinds of collections are wildcards.



public void print(Collection<?> c)
{
	for(Object o:c)
		System.out.println(o);
}
A List<Integer> is a subtype of Collection<?>
We can print anything we want (Integers, Doubles or String) but we can not insert into this Collection because we don't know the type.




================================================
Unbounded Wildcards example
================================================

public void print(Collection<?> c)
{
	for(Object o:c)
		System.out.println(o);
}
We are using Unbounded wildcard. So, java does not know It is Integer or String or any specific type. That's why we are using Object in for(Object o:c).
To tackle this situation, we can use bounded type parameter--
public class App {
	
	public static <T extends Number> void show(List<T> c) {
		for(Number o:c) {
			System.out.println(o);
		}
	}
	public static void main(String[] args) {
		List<Integer> list = Arrays.asList(100,200,300);
		show(list);
	}
	
}


Another Demostration:
--------------------------
public interface Shape
{
	public void draw();
}

public class Rectangle implements Shape
{
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}
}

public class Circle implements Shape 
{
	public void draw()
	{
		System.out.println("Drawing Circle");
	}
}


public class App
{
	public static void drawAll(List<?> list)
	{
		for(Object o:list)
			//o.draw(); This will give error. Object does not know about draw method.
			//if we do for(Shape s:list). It is also wrong because of Unbounded wildcard.
	}
	//So we can use bounded type parameter 
	public static <T extends Shape> void drawAll(List<T> list)
	{
		for(Shape s:list)
			s.draw();
	}
	public static void main(String[] args)
	{
		List<Rectangle> rectangles  = new ArrayList<>();
		rectangles.add(new Rectangle());
		drawAll(rectangles);
	}
}



======================================
Upper Bounded Wildcards
======================================
printAll(List<? extends T>)
- This method can accept a list of any subclass of T.

What if we want to add an item when using an upper bounded wildcard?
	addItem(List<? extends Number>)
We can not add an Integer to the List because the type can not be guaranteed - it may be List<Double>
We can not add an Double to the List because the type can not be guaranteed - it may be List<Integer>
The only thing that you can do is to read the item.


Question: What is the difference between Bounded type parameter and upper bounded wildcard?
Answer:  
	Using Bounded type parameter, we can read as well as add elements but to add elements you will have to add wisely
	public static <T extends Number> void drawAll(List<T> c, T item) {
		c.add(item);
		for(Number o:c)
			System.out.println(o.byteValue());
	}
	public static void main(String[] args) {
		List<Integer> list = new ArrayList<>();
		drawAll(list,100);
	}
	//Here, second argument will help in making clear 100 percent the type of the argument. 
	But, the below method--
	public static <T extends Number> void drawAll2(List<T> c)
	{
		c.add(100);// This is wrong.
		for(Number o:c)
			System.out.println(o.byteValue());
	}


	Using upper bounded wildcard, we can just read the elements.
	public static void drawAll(List<? extends Number> c) {
		for(Number n:c)
			System.out.println(n);
	}
	public static void main(String[] args) {
		
		List<Integer> list = Arrays.asList(10,20,30);
		drawAll(list);
	}



	But, suppose we want to add element, hardly what would you do. The below one??? :) Idiot ha ha ha ha 
	public static <T> void drawAll(List<? extends Number> c,T item) {  
		Now, how will you add. Even being orthodox can not add any value. But, suppose--
		c.add(item);  // How did you decide the type of List. Mr Orthodox,upper bounded wildcard and bounded type argument work in their own way. Bounded type argument will not decide type of List here.
		..
		..		
	}


======================================
Upper Bounded Wildcards Example
======================================


We can create ArrayLists like this--
List<? extends Number> list1 = new ArrayList<Integer>();
List<? extends Number> list2 = new ArrayList<Double>();
List<? extends Number> list3 = new ArrayList<Float>():












