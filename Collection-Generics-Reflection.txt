Compile time errors are easy to be detectable as the application will not be compiled. 
Runtime errors are more problematic.
So, prefer compile time errors to Runtime errors.

Why to use generics?
1)It makes most of the errors and bugs to be detectable at compile time and not at Runtime.
    Stronger type-check at compile time. If our code violates type safety then the compiler warns us.

2)generics enable types (classes and interfaces) to be parameters when defining other classes, interfaces and methods. We can reuse the same code with different inputs.
public void draw(Car car)
    Here, we are passing Car as a parameter.
public void draw(T t)
    We are using generic type.

3)We can eliminate type casting
    
    List list = new ArrayList<>();
    String name = (String)list.get(0); We are doing type casting

    List<String> list = new ArrayList<>();
    String name =  list.get(0);


===========================================================================================================

Problem Illustration

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void main(String[] args) {
		add(10,28);
	}
}

Here, we are dealing with only int type parameters.

What if we want to pass double type arguments. Then, we will have to overload the add method--

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void add(double num1, double num2) {
		double result = num1+num2;
		System.out.println("The result is: "+result);
	}
	public static void main(String[] args) {
		add(10.3,28.9);
	}
}

so, for  different types of arguments, we have to perform overloading. We can handle this situation using generics

***************************************************************

Another Problem Illustration--->

class Store{
	private Object item;

	public Object getItem() {
		return item;
	}

	public void setItem(Object item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store theStore = new Store();
		theStore.setItem(45);
		Integer result =  (Integer)theStore.getItem();
		System.out.println(result);
	}
}


What is the problem with this code?
1: theStore.setItem(45);
    We can change value from int (45) to double (45.5), compiler will not give any error. We will get error at run-time only.
2: We are type-casting.

**************************************************************************************************


*************************************************************************************************

class Store <T>{
	private T item;

	public T getItem() {
		return item;
	}

	public void setItem(T item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store<String> theStore = new Store<>();
		theStore.setItem("Hello World");
		String result =  theStore.getItem();
		System.out.println(result);
	}
}

Now, we are using generics. 
Suppose we want to pass String type.
    Store<String> theStore = new Store<>();
    Now, compiler will warn if we pass any other value except String in setItem() method. (Compile-time error)
We don't need to type cast 
    String result =  theStore.getItem();

In this programme, if we write Store theStore = new Store(); Store is a raw type. Now, it is not type safe and you will also have to do type-casting.
In case of collection, 
List list = new ArrayList();	(Compiler will warn us that you are using raw type)
list.add(20);					(Hey, we are not doing type-casting? Yes, In case of collection objects, we don't need to type caste despite the fact that we are using raw type of List.)


<>  This is diamond operator.

****************************************************************************************************************************

****************************************************************************************************************************

We have seen generics with a single generic type. We can use multiple generic types.

class Hashtable<K,V>{
	private K key;
	private V value;
	public Hashtable(K key, V value) {
		super();
		this.key = key;
		this.value = value;
	}
	@Override
	public String toString() {
		return "Hashtable [key=" + key + ", value=" + value + "]";
	}
	
	
}
public class App {

	
	public static void main(String[] args) {
		Hashtable<String,Integer> hashtable = new Hashtable<>("Hello",12);
		System.out.println(hashtable);
	}
}

Here, Hashtable is a custom class. Not the one from Collection framework.



********************************************************************************************************
Generic Methods 
********************************************************************************************************
We have seen generic types, now we will see generic methods--

public class GenericMethod {

	public <T> void showItem(T item) {
		System.out.println("The item is: "+item.toString());
	}
}



/**If we write 
public  void showItem(T item) {
		System.out.println("The item is: "+item.toString());
}

It will give compile time error in the parameter. We will have to use wildcard before return type.
public <T> void showItem(T item) {
		System.out.println("The item is: "+item.toString());
}**/


In Main application --
GenericMethod method = new GenericMethod();
method.showItem(whatever type of value you can pass);
Ex1- method.showItem(35);
Output- The item is 35
Ex2- method.showItem("Hello World");
Output- The item is Hello World.


We can also return Generic type.
public <T> T showItem(T item){
	System.out.println("The item is: "+item.toString());
	return T;
}



********************************************************************************************************
Generic Methods II 
********************************************************************************************************
Other Demostrations --

public <T,V> void printItems(T t, V v) {
		System.out.println(t.toString());
		System.out.println(v.toString());
}
	



public <T> void showItems(T[] items) {
	for(T t: items) 
		System.out.println(t);
	
}

In Main method--
Integer[] items = {10,20,30,40};			(We can not use int[] type array or any primitive type array)
method.showItems(items);


********************************************************************************************************
Exercise
********************************************************************************************************

Let's implement a generic method that checks 2 parameters share the same value or not!

For example:
checkEquality(12, 8) returns false
checkEquality(10.5, 10.5) returns true
checkEquality("Joe", "Joe") returns true


public class Exercise {

    // implement the checkEquality() method that takes 2 values as input parameters and it returns
    // a boolean value whether the values are mathcing or not
    public <T,V> boolean checkEquality(T t, V v){
        return t.equals(v);
    }
    public static void main(String args[]){
        Exercise ex = new Exercise();
        boolean result =  ex.checkEquality(100,100);
        System.out.println(result);
    }
}



********************************************************************************************************
Section 4: Bounded Type Parameters
Bounded type parameters
********************************************************************************************************

Sometimes we want to restrict the types that can be used as type arguments in a parameterized type.
A method that operates on numbers(integers, floats or doubles) might only want to accept instances of the Number class or its subclasses.

Bounded types allow you to invoke methods defined in the bounds.
public class App {

	public static <T extends Comparable<T>> T calculateMin(T num1,T num2) {
		if(num1.compareTo(num2)<0) {						//We are able to invoke method defined in Comparable interface.
			return num1;
		}
		return num2;
	}
	public static void main(String[] args) {
		System.out.println(calculateMin("Hello","Anvesh"));
		System.out.println(calculateMin('k','a'));
		System.out.println(calculateMin(100,90));
	}
}


-------------------------------------------------------------
Another Demostration:
class Person implements Comparable<Person>{
	
	private int age;
	private String name;
	
	public Person(String name,int age) {
		this.age = age;
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public int compareTo(Person otherPerson) {
		return Integer.compare(age, otherPerson.getAge());
	}
	@Override
	public String toString() {
		return "Person [age=" + age + ", name=" + name + "]";
	}
	
}

public class App {

	public static <T extends Comparable<T>> T calculateMin(T num1,T num2) {
		if(num1.compareTo(num2)<0) {
			return num1;
		}
		return num2;
	}
	public static void main(String[] args) {
		System.out.println(calculateMin(new Person("Kevin",48),new Person("Henry",78)));
	}
}


-----------------------------------------------------------------------------------------------------------------------------------

***************************************
Section 5: Type Inference 
***************************************

What is Type Inference? 
Answer: It is the ability of compiler to determine the exact type that works with all the arguments.

		public class App {
			public static <T> void getData(T t1, T t2) {
				System.out.println(t1);;
			}
			public static void main(String[] args) {
				getData("Hello",new ArrayList<>());
			}
		}

		
		The above and below examples work fine.
		Here, String and ArrayList both implements Serializable. So, in 'public static <T> void get....', T is of Serializable type.

		public class App {
			public static <T> T getData(T t1, T t2) {
				return t1;
			}
			public static void main(String[] args) {
				Serializable s = getData("Hello",new ArrayList<>());
			}
	
		}





Because of the type inference, we can use class instantiation like this--
List<String> list = new ArrayList<>();



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class Bucket<T>{
	private T item;
	
	public T getItem() {
		return item;
	}
	public void setItem(T item) {
		this.item = item;
	}
}
public class App {
	
	public static <T> void addStore(T t, List<Bucket<T>> list) {
		Bucket<T> bucket = new Bucket<>();
		bucket.setItem(t);
		list.add(bucket);
		System.out.println(t.toString()+" has been added to the bucket");
	}
	
	public static void main(String[] args) {
		List<Bucket<String>> list = new ArrayList<>();
		App.addStore("Adam", list); //Java Compiler is going to determine the type of T (which is String here)
								//first argument is of type String and second argument is of type List of bucket of String
								//compiler will determine the type of T (in public static <T> void...) to be String.
		//type witness
		App.<String>addStore("Dani Daniels",list);
	}
	
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Another example of Type Inference
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

public class App {
	
	public static <T> List<T> show(List<T> list, T t1, T t2){
		list.add(t1);
		list.add(t2);
		return list;
	}
	
	public static void main(String[] args) {
		List<String> list = show(new ArrayList<>(),"Hello","Sunny");
		System.out.println(list);
	}
	
}
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

============================================================================================================================================

************************************************
Section 6: Wildcards 
************************************************

Integer is a subtype of Number.
List<Integer> is not a subtype of List<Number> despite the fact that Integer is a Number.
This is why we need Wildcards.


public void print(Collection<Object> c)
{
	for(Object o:c)
		System.out.println(o);
}
It will not work fine if we pass List<Integer> or List<String>.
This is why we need to consider Wildcards -  the supertype of all kinds of collections are wildcards.



public void print(Collection<?> c)
{
	for(Object o:c)
		System.out.println(o);
}
A List<Integer> is a subtype of Collection<?>
We can print anything we want (Integers, Doubles or String) but we can not insert into this Collection because we don't know the type.




================================================
Unbounded Wildcards example
================================================

public void print(Collection<?> c)
{
	for(Object o:c)
		System.out.println(o);
}
We are using Unbounded wildcard. So, java does not know It is Integer or String or any specific type. That's why we are using Object in for(Object o:c).
To tackle this situation, we can use bounded type parameter--
public class App {
	
	public static <T extends Number> void show(List<T> c) {
		for(Number o:c) {
			System.out.println(o);
		}
	}
	public static void main(String[] args) {
		List<Integer> list = Arrays.asList(100,200,300);
		show(list);
	}
	
}


Another Demostration:
--------------------------
public interface Shape
{
	public void draw();
}

public class Rectangle implements Shape
{
	public void draw()
	{
		System.out.println("Drawing Rectangle");
	}
}

public class Circle implements Shape 
{
	public void draw()
	{
		System.out.println("Drawing Circle");
	}
}


public class App
{
	public static void drawAll(List<?> list)
	{
		for(Object o:list)
			//o.draw(); This will give error. Object does not know about draw method.
			//if we do for(Shape s:list). It is also wrong because of Unbounded wildcard.
	}
	//So we can use bounded type parameter 
	public static <T extends Shape> void drawAll(List<T> list)
	{
		for(Shape s:list)
			s.draw();
	}
	public static void main(String[] args)
	{
		List<Rectangle> rectangles  = new ArrayList<>();
		rectangles.add(new Rectangle());
		drawAll(rectangles);
	}
}



======================================
Upper Bounded Wildcards
======================================
printAll(List<? extends T>)
- This method can accept a list of any subclass of T.

What if we want to add an item when using an upper bounded wildcard?
	addItem(List<? extends Number>)
We can not add an Integer to the List because the type can not be guaranteed - it may be List<Double>
We can not add an Double to the List because the type can not be guaranteed - it may be List<Integer>
The only thing that you can do is to read the item.


Question: What is the difference between Bounded type parameter and upper bounded wildcard?
Answer:  
	Using Bounded type parameter, we can read as well as add elements but to add elements you will have to add wisely
	public static <T extends Number> void drawAll(List<T> c, T item) {
		c.add(item);
		for(Number o:c)
			System.out.println(o.byteValue());
	}
	public static void main(String[] args) {
		List<Integer> list = new ArrayList<>();
		drawAll(list,100);
	}
	//Here, second argument will help in making clear 100 percent the type of the argument. 
	But, the below method--
	public static <T extends Number> void drawAll2(List<T> c)
	{
		c.add(100);// This is wrong.
		for(Number o:c)
			System.out.println(o.byteValue());
	}


	Using upper bounded wildcard, we can just read the elements.
	public static void drawAll(List<? extends Number> c) {
		for(Number n:c)
			System.out.println(n);
	}
	public static void main(String[] args) {
		
		List<Integer> list = Arrays.asList(10,20,30);
		drawAll(list);
	}



	But, suppose we want to add element, hardly what would you do. The below one??? :) Idiot ha ha ha ha 
	public static <T> void drawAll(List<? extends Number> c,T item) {  
		Now, how will you add. Even being orthodox can not add any value. But, suppose--
		c.add(item);  // How did you decide the type of List. Mr Orthodox,upper bounded wildcard and bounded type argument work in their own way. Bounded type argument will not decide type of List here.
		..
		..		
	}


======================================
Upper Bounded Wildcards Example
======================================


We can create ArrayLists like this--
List<? extends Number> list1 = new ArrayList<Integer>();
List<? extends Number> list2 = new ArrayList<Double>();
List<? extends Number> list3 = new ArrayList<Float>():



==================================
Lower Bounded Wildcards
==================================
printAll(List<? super T>)
This method can accept a list of any superclass of T.

addItem(List<? super Integer>)
We can add an Integer to the list without any problem.
We can add Numbers or even Objects to the list because Numbers and Objects are superclasses of Integers.

You can not read items from a List<? super T> because you can not guarantee what list it is really pointing to - we can read Objects exclusively.
We can insert subtypes of T into a List<? super T>


The below example is just going to work fine--
----------------------------------------------------
public static void showAll(List<? super Integer> c) {
		for(Object n:c) {
			System.out.println(n);
		}
	}
	
	public static void main(String[] args) {
		
		List<? super Integer> l1 = new ArrayList<Integer>();
		List<? super Integer> l2 = new ArrayList<Number>();
		List<? super Integer> l3 = new ArrayList<Object>();
	}
	
But, If I Use Number or any other Class in for loop, it will give error.


Now, Inserting into lower bounded wildcard--
List<? super Number> list = new ArrayList<>();
list.add(100);
list.add(100L);
list.add(100.09);
//list.add("Hello World"); Not Ok


--------------------------------------------------------------------------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------------------------------------------
Section 9: Collection Framework
-------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------
How to measure the running time of algorithms?
--------------------------------------------------

Running Time of Algorithms 
--------------------------
It is quite hard to define the running time of a given algorithm- because it depends upon underlying hardware. So, may be measuring the running time is not the best option possible.
better approach: measure the number of steps instead- how many steps a given algorithm requires with respect to the input. For example: We want to sort an array with N items. How many steps does the given sorting algorithm requires?

O(1)- Constant Running time complexity
	These algorithms are the fastest approaches: the running time is independent of the N input (number of items)
	Example: We want to swap two items with known indexes in a given one-dimensional array.
			 We want to access a particular item of known index from a given array.

O(N)- linear running time complexity
	These algorithms' running time scale linearly with the N input so the running time increases linearly with the size of the input.
	if we have 2x the size of the input then the running time will be 2x as well.
	Example: If we want to find an unknown item in an unsorted one-dimensional array. (linear search)
			 int[] a = new int[] {5,-4,8,2,1,12}; Suppose we want to find 1.
			 Linear search will search from the left-hand side one-by-one.

O(logN)- logarithmic running time complexity
	These algorithms' running time scale logarithmically with the N input so the running time increases logarithmically with the size of the input.
	Example: If we want to find an unknown item in a sorted one-dimensional array (binary search)

Running Time Complexity--
O(1)
O(logN)
O(N)
O(NlogN)
.
.

O(logN) is close very close to O(1).










---------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------
Section 10: Lists 
--------------------------------------------

-------------------------------
The List Interface 
-------------------------------
-The list interface is an ordered collection that allows us to store and access items in a sequential manner.
-It extends the Collection interface, Collection extends Iterable interface, so List extends Iterable interface.
-List can store duplicate elements (while sets can not)
-It gives the user full visibility and control over the ordering of its elements.


List<String> names  = new ArrayList<>();
names.add("Adam");
names.add("Kevin");
names.add("Emily");

Iterator<String> iter = names.iterator();
while(iter.hasNext())
	System.out.println(iter.next());

Or we can use forEach loop to iterate names--
for(String name:names)
	System.out.println(name);



----------------------------------------------------------
What are Arrays?
----------------------------------------------------------

What is the aim of a data structure?
The aim is to make operations as fast as possible such as inserting new items or removing given items from the data structure.
Arrays are data structures where all the items are identified by an index - an integer starting with 0.
The items of arrays are located right next to each other in the main memory (RAM) - they can be accessed by the index.

Accessing items based on the indexes (random indexing) is the main advantage of array data structures.
Random Access: Items are located right next to each other so we can get them with the help of the index - in O(1) running time.

The main problem with Arrays is that we have to know the number of items we want to store in advance (static arrays).
Static Arrays--size of arrays does not change.
Dynamic Arrays--size of arrays may change dynamically. (Example- ArrayList)

-More complex complex data structures rely heavily on arrays because of random indexing - O(1) access of items with known indexes. 
Ex- Stacks, Queues and HashTables 





---------------------------------------------------------------------------------------------------
Array Operations Visualization
---------------------------------------------------------------------------------------------------

Array Data Structure 
------------------------------------
ADDING ITEMS :-
----------------
We can insert new items to the end of the data structure until the data structure is not full - O(1) running time.
What if the data structure becomes full?
- have to allocate a larger chunk of memory in the RAM (usually 2x the size of the actual array)
- have to copy the existing items one by one to the new array.
- because of these operations: the resize operation takes O(N) linear running time complexity - this is the bottleneck.


MEMORY AND RUNNING TIME TRADE-OFF:-
------------------------------------
Start with a small sized array- We don't waste memory but we have to resize the array often with O(N) running time.
Allocate the huge array at the beginning- We do waste memory because of the large size but at least we do not have to bother with the resize operation.


ADDING ITEMS :-
----------------
We can insert new items to arbitrary positions associated with a given index (we may have to shift items)
It is an O(N) linear running time complexity because the items must be shifted. ( in worst-case all the items)


Removing Items:-
------------------
We can remove the last item quite fast - in O(1) constant running time complexity.
Removing an arbitrary item of the array -- We may shift multiple items - O(N) running time complexity.
	First we have to find the item in O(N) in running time then remove the item in O(1) and finally have to shift the other items in O(N)
	O(N) + O(1) + O(N) = O(N)

OPERATION 				                       RUNNING TIME
------------------------------------------------------------------
search based on index	<--------------------->O(1)			   

search for arbitrary item (no index) <-------->O(N)

insert item to the end of array <------------->O(1)

insert item to arbitrary position <----------->O(N)

removing last item <-------------------------->O(1)

removing arbitrary item <--------------------->O(N)






---------------------------------------------------------------------------------------------------
ArrayList Example
---------------------------------------------------------------------------------------------------

ArrayList() constructs an empty list with an initial capacity of ten.



If we know we are going to store 5 million elements in ArrayList, then it is better to specify capacity because java will have to increase the size multiple times and it will be very expensive. 

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// resizing the array takes O(N)
List<String> names = new ArrayList<>();

names.add("Kevin");
names.add("Adam");
names.add("Ana");

// random accessing in O(1)   [This is the main advantage as far as the ArrayLists are concerned]
System.out.println(names.get(0));

// inserting item into a given index - O(N)
names.add(0,"Daniel");
0 <-----> Kevin   												0 <---------> Daniel 
1 <-----> Adam --------------After Inserting---------------> 	1 <---------> Kevin
2 <-----> Ana													2 <---------> Adam 
																3 <---------> Ana 
// removing item from a given index - O(N)
0 <---------> Daniel			                                0 <---------> Kevin
1 <---------> Kevin ---------------- After Removing--------->   1 <---------> Adam 
2 <---------> Adam                                              2 <---------> Ana
3 <---------> Ana

//ARRAYLIST (ARRAYS) ARE FAST IF WE MANIPULATE THE LAST ITEM.

//because of Iterable interface 
for(String name:names)
	System.out.println(name);


Object[] o = names.toArray();
for(Object name:o)
	System.out.println(name);


//contains will check whether the item is present in the array 
System.out.println(names.contains("Katy"));

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++








