Compile time errors are easy to be detectable as the application will not be compiled. 
Runtime errors are more problematic.
So, prefer compile time errors to Runtime errors.

Why to use generics?
1)It makes most of the errors and bugs to be detectable at compile time and not at Runtime.
    Stronger type-check at compile time. If our code violates type safety then the compiler warns us.

2)generics enable types (classes and interfaces) to be parameters when defining other classes, interfaces and methods. We can reuse the same code with different inputs.
public void draw(Car car)
    Here, we are passing Car as a parameter.
public void draw(T t)
    We are using generic type.

3)We can eliminate type casting
    
    List list = new ArrayList<>();
    String name = (String)list.get(0); We are doing type casting

    List<String> list = new ArrayList<>();
    String name =  list.get(0);


===========================================================================================================

Problem Illustration

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void main(String[] args) {
		add(10,28);
	}
}

Here, we are dealing with only int type parameters.

What if we want to pass double type arguments. Then, we will have to overload the add method--

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void add(double num1, double num2) {
		double result = num1+num2;
		System.out.println("The result is: "+result);
	}
	public static void main(String[] args) {
		add(10.3,28.9);
	}
}

so, for  different types of arguments, we have to perform overloading. We can handle this situation using generics

***************************************************************

Another Problem Illustration--->

class Store{
	private Object item;

	public Object getItem() {
		return item;
	}

	public void setItem(Object item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store theStore = new Store();
		theStore.setItem(45);
		Integer result =  (Integer)theStore.getItem();
		System.out.println(result);
	}
}


What is the problem with this code?
1: theStore.setItem(45);
    We can change value from int (45) to double (45.5), compiler will not give any error. We will get error at run-time only.
2: We are type-casting.

**************************************************************************************************


*************************************************************************************************

class Store <T>{
	private T item;

	public T getItem() {
		return item;
	}

	public void setItem(T item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store<String> theStore = new Store<>();
		theStore.setItem("Hello World");
		String result =  theStore.getItem();
		System.out.println(result);
	}
}

Now, we are using generics. 
Suppose we want to pass String type.
    Store<String> theStore = new Store<>();
    Now, compiler will warn if we pass any other value except String in setItem() method. (Compile-time error)
We don't need to type cast 
    String result =  theStore.getItem();

In this programme, if we write Store theStore = new Store(); Store is a raw type. Now, it is not type safe and you will also have to do type-casting.
In case of collection, 
List list = new ArrayList();	(Compiler will warn us that you are using raw type)
list.add(20);					(Hey, we are not doing type-casting? Yes, In case of collection objects, we don't need to type caste despite the fact that we are using raw type of List.)


<>  This is diamond operator.

****************************************************************************************************************************

****************************************************************************************************************************

We have seen generics with a single generic type. We can use multiple generic types.

class Hashtable<K,V>{
	private K key;
	private V value;
	public Hashtable(K key, V value) {
		super();
		this.key = key;
		this.value = value;
	}
	@Override
	public String toString() {
		return "Hashtable [key=" + key + ", value=" + value + "]";
	}
	
	
}
public class App {

	
	public static void main(String[] args) {
		Hashtable<String,Integer> hashtable = new Hashtable<>("Hello",12);
		System.out.println(hashtable);
	}
}

Here, Hashtable is a custom class. Not the one from Collection framework.



********************************************************************************************************
Generic Methods 
********************************************************************************************************
We have seen generic types, now we will see generic methods--

public class GenericMethod {

	public <T> void showItem(T item) {
		System.out.println("The item is: "+item.toString());
	}
}



/**If we write 
public  void showItem(T item) {
		System.out.println("The item is: "+item.toString());
}

It will give compile time error in the parameter. We will have to use wildcard before return type.
public <T> void showItem(T item) {
		System.out.println("The item is: "+item.toString());
}**/


In Main application --
GenericMethod method = new GenericMethod();
method.showItem(whatever type of value you can pass);
Ex1- method.showItem(35);
Output- The item is 35
Ex2- method.showItem("Hello World");
Output- The item is Hello World.


We can also return Generic type.
public <T> T showItem(T item){
	System.out.println("The item is: "+item.toString());
	return T;
}



********************************************************************************************************
Generic Methods II 
********************************************************************************************************
Other Demostrations --

public <T,V> void printItems(T t, V v) {
		System.out.println(t.toString());
		System.out.println(v.toString());
}
	



public <T> void showItems(T[] items) {
	for(T t: items) 
		System.out.println(t);
	
}

In Main method--
Integer[] items = {10,20,30,40};			(We can not use int[] type array or any primitive type array)
method.showItems(items);


********************************************************************************************************
Exercise
********************************************************************************************************

Let's implement a generic method that checks 2 parameters share the same value or not!

For example:
checkEquality(12, 8) returns false
checkEquality(10.5, 10.5) returns true
checkEquality("Joe", "Joe") returns true


public class Exercise {

    // implement the checkEquality() method that takes 2 values as input parameters and it returns
    // a boolean value whether the values are mathcing or not
    public <T,V> boolean checkEquality(T t, V v){
        return t.equals(v);
    }
    public static void main(String args[]){
        Exercise ex = new Exercise();
        boolean result =  ex.checkEquality(100,100);
        System.out.println(result);
    }
}



********************************************************************************************************
Section 4: Bounded Type Parameters
Bounded type parameters
********************************************************************************************************

Sometimes we want to restrict the types that can be used as type arguments in a parameterized type.
A method that operates on numbers(integers, floats or doubles) might only want to accept instances of the Number class or its subclasses.

Bounded types allow you to invoke methods defined in the bounds.
public class App {

	public static <T extends Comparable<T>> T calculateMin(T num1,T num2) {
		if(num1.compareTo(num2)<0) {						//We are able to invoke method defined in Comparable interface.
			return num1;
		}
		return num2;
	}
	public static void main(String[] args) {
		System.out.println(calculateMin("Hello","Anvesh"));
		System.out.println(calculateMin('k','a'));
		System.out.println(calculateMin(100,90));
	}
}


-------------------------------------------------------------
Another Demostration:
class Person implements Comparable<Person>{
	
	private int age;
	private String name;
	
	public Person(String name,int age) {
		this.age = age;
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public int compareTo(Person otherPerson) {
		return Integer.compare(age, otherPerson.getAge());
	}
	@Override
	public String toString() {
		return "Person [age=" + age + ", name=" + name + "]";
	}
	
}

public class App {

	public static <T extends Comparable<T>> T calculateMin(T num1,T num2) {
		if(num1.compareTo(num2)<0) {
			return num1;
		}
		return num2;
	}
	public static void main(String[] args) {
		System.out.println(calculateMin(new Person("Kevin",48),new Person("Henry",78)));
	}
}




























