Compile time errors are easy to be detectable as the application will not be compiled. 
Runtime errors are more problematic.
So, prefer compile time errors to Runtime errors.

Why to use generics?
1)It makes most of the errors and bugs to be detectable at compile time and not at Runtime.
    Stronger type-check at compile time. If our code violates type safety then the compiler warns us.

2)generics enable types (classes and interfaces) to be parameters when defining other classes, interfaces and methods. We can reuse the same code with different inputs.
public void draw(Car car)
    Here, we are passing Car as a parameter.
public void draw(T t)
    We are using generic type.

3)We can eliminate type casting
    
    List list = new ArrayList<>();
    String name = (String)list.get(0); We are doing type casting

    List<String> list = new ArrayList<>();
    String name =  list.get(0);


===========================================================================================================

Problem Illustration

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void main(String[] args) {
		add(10,28);
	}
}

Here, we are dealing with only int type parameters.

What if we want to pass double type arguments. Then, we will have to overload the add method--

public class App {

	public static void add(int num1, int num2) {
		int result = num1+num2;
		System.out.println("The result is: "+result);
	}
	
	public static void add(double num1, double num2) {
		double result = num1+num2;
		System.out.println("The result is: "+result);
	}
	public static void main(String[] args) {
		add(10.3,28.9);
	}
}

so, for  different types of arguments, we have to perform overloading. We can handle this situation using generics

***************************************************************

Another Problem Illustration--->

class Store{
	private Object item;

	public Object getItem() {
		return item;
	}

	public void setItem(Object item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store theStore = new Store();
		theStore.setItem(45);
		Integer result =  (Integer)theStore.getItem();
		System.out.println(result);
	}
}


What is the problem with this code?
1: theStore.setItem(45);
    We can change value from int (45) to double (45.5), compiler will not give any error. We will get error at run-time only.
2: We are type-casting.

**************************************************************************************************


*************************************************************************************************

class Store <T>{
	private T item;

	public T getItem() {
		return item;
	}

	public void setItem(T item) {
		this.item = item;
	}	
		
}
public class App {

	
	public static void main(String[] args) {
		Store<String> theStore = new Store<>();
		theStore.setItem("Hello World");
		String result =  theStore.getItem();
		System.out.println(result);
	}
}

Now, we are using generics. 
Suppose we want to pass String type.
    Store<String> theStore = new Store<>();
    Now, compiler will warn if we pass any other value except String in setItem() method. (Compile-time error)
We don't need to type cast 
    String result =  theStore.getItem();

****************************************************************************************************************************











