==========================================================================================================================================================
ADVANCED MAPPING
==========================================================================================================================================================
If there are multiple tables and if there is relationship between them. 
If we want to model this relationship using Hibernate, we use advanced mappings. 

One to One
One to Many/Many to One
Many to Many



=========================================================================================================================================================
ONE TO ONE
------------------


For Example:-
	Instructor -------------> Instructor Detail
	
	
	instructor								instructor_detail
	-----------------							--------------------------------------
	id INT(11)								id INT(11)
	first_name VARCHAR(45)							youtube_channel VARCHAR(128)
	last_name VARCHAR(45)							hobby VARCHAR(45)
	email VARCHAR(45)
	instructor_detail_id INT(11)	

Here, instructor_detail_id is a primary key column which refers to primay key column of instructor_detail. 	
In the Query of instructor table:-
CONSTRAINT `FK_DETAIL` FOREIGN KEY (`instructor_detail_id`)
REFERENCES `instructor_detail` (`id`)




One-to-Many Mapping
--------------------------
An Instructor can have many Courses. 






Many-to-Many Mapping
------------------------
A course can have many students
A student can have many courses


In advanced mapping, we use foreign key. 
Foreign key links table together.
A field in one table refers to primary key in another table. 

	



CASCADE
--------------
We can cascade operations. Cascading means applying the same operation on related entities. 


Fetch Types: Eager vs Lazy Loading
--------------------------------------
Eager will retrieve everything
Lazy will retrieve on request

For example, in one-to-Many mapping, where an Instructor can have Multple Courses. It is recommended to use FetchType Lazy loading. 



Uni-Directional
--------------------------
	
			Instructor ---------------------------> Instructor-Detail
			
			
Bi-Directional
---------------------------

			Instructor <----------------------------> Instructor-Detail




==================================================================================================================================================================================================
												ONE TO ONE 


Uni-Directional
--------------------------
	
			Instructor ---------------------------> Instructor-Detail



Create InstructorDetail class
---------------------------------
@Entity
@Table(name="instructor_detail")
public class InstructorDetail {

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	private int id;
	
	@Column(name="youtube_channel")
	private String youtubeChannel;
	
	@Column(name="hobby")
	private String hobby;
	
	// constructors
	// getters / setters

}



Create Instructor class
----------------------------

@Entity
@Table(name="instructor")
public class Instructor {
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	private int id;
	
	@Column(name="first_name")
	private String firstName;
	
	@Column(name="last_name")
	private String lastName;
	
	@Column(name="email")
	private String email;
	
	@OneToOne
	@JoinColumn(name=“instructor_detail_id")           ("instructor_detail_id" is the name of the column present in instruct table. It is a column that refereces to id on instructor_detail table)				 			
	private InstructorDetail instructorDetail;
	
	//settter and getter for InstructorDetail property
	
	// constructors, getters / setters
}





What is Entity LifyCycle?
----------------------------------
Detach:- 
	Suppose we want to update an Entity. We get the object (entityManager.find()) using primary key. It is in the detached stated (Not attached to Hibernate session). Now, we Update it and merge it. Merge will reattach the object to Hibernate session and next commit will update the object in database with the . 

Merge:- If instance is detached from session, merge will bring that instance in persistent state and the next flush/commit will update the object in database.

Persist/Managed: When we save or persist, the instance goes into persistent or managed state. Next flush/commit will save the instance in db. 

Remove:- Transitions managed state to removed. Next flush/commit will delete instace from db. 

Refresh:- Sync with database object.  



What are different Cascade Types
---------------------------------------
PERSIST:-If entity is persisted/saved, related entity will also be persisted.

REMOVE:- If entity is removed/deleted, related entity will also be deleted.

REFRESH:- If entity is refreshed, related entity will also be refreshed. 

MERGE:- If entity is detached (not associated w/ session), then related entity will also be detached

DETACH:- If entity is detached, related entity will also be detached. 

ALL:- All of above cascade types



By default, no operations are cascaded. 

Configure Cascade type
----------------------------

@Entity
@Table(name="instructor")
public class Instructor {
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	private int id;
	
	@Column(name="first_name")
	private String firstName;
	
	@Column(name="last_name")
	private String lastName;
	
	@Column(name="email")
	private String email;
	
	@OneToOne(cascade=CascadeType.ALL)
	@JoinColumn(name=“instructor_detail_id")          
	…
	// constructors, getters / setters
}




==================================================================================================================================================================================================
			CREATING SPRING BOOT COMMAND LINE APPLICATON
			
		
DAO interface
--------------------------
public interface AppDAO{
	
	void save(Instructor theInstructor);
}

DAO implementation
-----------------------------
@Repository
public class AppDAOImpl implements AppDAO{

	
	private EntityManager entityManager;
	
	@Autowired
	public AppDAOImpl(EntityManager entityManager) {
	this.entityManager = entityManager;
	}
	
	@Override
	@Transactional
	public void save(Instructor theInstructor) {
	entityManager.persist(theInstructor);				(It will also save InstructorDetails Object because CascadeType.ALL)
	}
}


Update Main App
---------------------------

public class MainApplication{
	
	public static void main(String args[]){
		
		SpringApplication.run(MainApplication.class,args);

	}
	
	@Bean
	public CommandLineRunner commandLineRunner(AppDAO appDAO) {
		
		return runner->{
			
			createInstructor(appDAO);
		
		}
	}
	
	private void createInstructor(AppDAO appDAO) {
		Instructor tempInstructor =
			new Instructor("Chad", "Darby", "darby@luv2code.com");
		
		InstructorDetail tempInstructorDetail =
			new InstructorDetail(
				"http://www.luv2code.com/youtube",
				"Luv 2 code!!!");
				
		tempInstructor.setInstructorDetail(tempInstructorDetail);
		
		appDAO.save(tempInstructor);						(It will also save InstructorDetails becasue of CascadeType.ALL)
		
	}
}


Find An Entity
--------------------------------

DAO interface
--------------------------
public interface AppDAO{
	
	void save(Instructor theInstructor);
	Instructor findInstructorById(Integer id);
}


DAO implementation
-----------------------------
@Repository
public class AppDAOImpl implements AppDAO{

	
	private EntityManager entityManager;
	
	@Autowired
	public AppDAOImpl(EntityManager entityManager) {
	this.entityManager = entityManager;
	}
	
	@Override
	@Transactional
	public void save(Instructor theInstructor) {
	entityManager.persist(theInstructor);				(It will also save InstructorDetails Object because CascadeType.ALL)
	}
	
	@Override
	public Instructor findInstructorById(int theId) {
	return entityManager.find(Instructor.class, theId);		(This will also retrieve Instructor Details object because default fetch type One To One is Eager loading)
	}
}



Delete an Entity
----------------------
DAO interface
--------------------------
public interface AppDAO{
	
	void save(Instructor theInstructor);
	Instructor findInstructorById(Integer id);
	void deleteInstructorById(Integer id);
}

DAO implementation
-----------------------------
@Repository
public class AppDAOImpl implements AppDAO{

	
	private EntityManager entityManager;
	
	@Autowired
	public AppDAOImpl(EntityManager entityManager) {
	this.entityManager = entityManager;
	}
	
	@Override
	@Transactional
	public void save(Instructor theInstructor) {
	entityManager.persist(theInstructor);				(It will also save InstructorDetails Object because CascadeType.ALL)
	}
	
	@Override
	public Instructor findInstructorById(int theId) {
	return entityManager.find(Instructor.class, theId);		(This will also retrieve Instructor Details object because default fetch type One To One is Eager loading)
	}
	
	@Override
	@Transactional
	public void deleteInstructorById(Integer id){
	
		Instructor tempInstructor=entityManager.find(Instructor.class, id);
		
		entityManager.remove(tempInstructor);			(This will also delete InstructorDetail object because of CascadeType.DELETE)
		
	}
}


==================================================================================================================================================================================================
									ONE TO ONE (BI-Directional)
									
Use-Case
--------------
If we load InstructorDetail, we should get associated Instructor.

We can't do this with current association which is one to one uni directional from Instructor to Instructor Detail.

		Instructor<--------------------------------->Instructor Detail

We don't need any change in our java code, we just need to add some some in our InstructorDetail class:-
--------------------------------------------------------------------------------------------------------

@Entity
@Table(name="instructor_detail")
public class InstructorDetail {

	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	private int id;
	
	@Column(name="youtube_channel")
	private String youtubeChannel;
	
	@Column(name="hobby")
	private String hobby;
	
	@OneToOne(mappedBy="instructorDetail",cascade=CascadeType.ALL)			(refers to "instructorDetail" property in "Instructor" class)
	private Instructor instructor;
	
	public Instructor getInstructor() {
		return instructor;
	}
	public void setInstructor(Instructor instructor) {
		this.instructor = instructor;
	}
	
	// constructors
	// getters / setters

}


DAO interface
--------------------------
public interface AppDAO{
	
	void save(Instructor theInstructor);
	Instructor findInstructorById(Integer id);
	void deleteInstructorById(Integer id);
	InstructorDetail findInstructorDetailById(Integer theId);
}


DAO implementation
-----------------------------
@Repository
public class AppDAOImpl implements AppDAO{

	
	private EntityManager entityManager;
	
	@Autowired
	public AppDAOImpl(EntityManager entityManager) {
	this.entityManager = entityManager;
	}
	
	@Override
	@Transactional
	public void save(Instructor theInstructor) {
	entityManager.persist(theInstructor);				(It will also save InstructorDetails Object because CascadeType.ALL)
	}
	
	@Override
	public Instructor findInstructorById(int theId) {
	return entityManager.find(Instructor.class, theId);		(This will also retrieve Instructor Details object because default fetch type One To One is Eager loading)
	}
	
	@Override
	@Transactional
	public void deleteInstructorById(Integer id){
	
		Instructor tempInstructor=entityManager.find(Instructor.class, id);
		
		entityManager.remove(tempInstructor);			(This will also delete InstructorDetail object because of CascadeType.DELETE)
		
	}
	
	@Override
	public InstructorDetail findInstructorDetailById(Integer theId){
		return entityManager.find(InstructorDetail.class,theId);	(This will also retrieve Instructor detail because of default behaviour of @OneToOne which is fetch type eager loading)
	}
}




Update Main App
---------------------------

public class MainApplication{
	
	public static void main(String args[]){
		
		SpringApplication.run(MainApplication.class,args);

	}
	
	@Bean
	public CommandLineRunner commandLineRunner(AppDAO appDAO) {
		
		return runner->{
			
			createInstructor(appDAO);
			findInstructorDetail(appDAO);
		
		}
	}
	
	private void createInstructor(AppDAO appDAO) {
		Instructor tempInstructor =
			new Instructor("Chad", "Darby", "darby@luv2code.com");
		
		InstructorDetail tempInstructorDetail =
			new InstructorDetail(
				"http://www.luv2code.com/youtube",
				"Luv 2 code!!!");
				
		tempInstructor.setInstructorDetail(tempInstructorDetail);
		
		appDAO.save(tempInstructor);						(It will also save InstructorDetails becasue of CascadeType.ALL)
		
	}
	
	private void findInstructorDetail(AppDAO appDAO) {
		int theId = 1;
		InstructorDetail tempInstructorDetail = appDAO.findInstructorDetailById(theId);
		
		System.out.println("tempInstructorDetail: " + tempInstructorDetail);
		System.out.println("the associated instructor: " + tempInstructorDetail.getInstructor());
	}
}




==================================================================================================================================================================================================

										(One-to-Many) (Bi-Directional)
										



	   <------->Course
	   <------->Course
Instructor <------->Course
	   <------->Course
	   <------->Course
	   


One to Many---> An Instructor can have many Courses. 

Many to One---> Many Courses can have One Instructor


Table Course
---------------
id INT(11)
title VARCHAR(45)
instructor_id INT(11)

CREATE TABLE `course` (
	`id` int(11) NOT NULL AUTO_INCREMENT,
	`title` varchar(128) DEFAULT NULL,
	`instructor_id` int(11) DEFAULT NULL,
	
	PRIMARY KEY (`id`),
	UNIQUE KEY `TITLE_UNIQUE` (`title`),
	CONSTRAINT `FK_INSTRUCTOR`
	
	FOREIGN KEY (`instructor_id`)
	REFERENCES `instructor` (`id`)
}
	
	
Course class
-----------------------
@Entity
@Table(name="course")
public class Course {
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	@Column(name="id")
	
	private int id;
	@Column(name="title")
	private String title;
	
	@ManyToOne(cascade={CascadeType.PERSIST, CascadeType.MERGECascadeType.DETACH, CascadeType.REFRESH})
	@JoinColumn(name="instructor_id")		(It is the column in Course class which refers to id column of Instructor class)
	private Instructor instructor;
	…
	// constructors, getters / setters
}									
										

Update Instructor
-------------------------

@Entity
@Table(name="instructor")
public class Instructor {
	
	...
	...
	@OneToMany(mappedBy="instructor",cascade={CascadeType.PERSIST, CascadeType.MERGECascadeType.DETACH, CascadeType.REFRESH})	(Refers to instructor property in Course class)
	private List<Course> courses;
	//setter and getter for course
	...
	...
}


We defined cascading in the way that we don't apply cascading delete for both the entities.




==================================================================================================================================================================================================
										FETCH TYPES
										
































