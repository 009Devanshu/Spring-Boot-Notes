@beforeEach
@afterEach
@beforeAll (should be static) 
@afterAll (should be static)

Display Names:-
---------------------
Define these annotations on class:-
//@DisplayNameGeneration(DisplayNameGenerator.Simple.class) ----> Removes trailing parentheses from test method name
//@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)----> Replaces underscores in test method name with spaces
//@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class) ----> Generate sentence based on test class name and test method name

Define this annotation on method:-
//@DisplayName("Equals and Not Equals")  (No need to write annotations above along with this)



-------------------------------------------
Test for Same and NotSame 
assertSame(p1,p2,"Message")----------> Assert that items refer to the same object. 
assertNotSame(p1,p2,"Message")-------> Assert that items do not refer to the same object.


Test for True and False 
assertTrue(P1,"Message") 
assertFalse(p1,"Message") 

------------------------------------------------------------

Junit Assertions: Arrays, Iterables and Lines 
**********************************************

assertArrayEquals:- assert that both object arrays are deeply equal 
assertIterableEquals:-> assert that both object iterables are deeply equal 
assertLinesMatch:- assert that both lists of Strings match 


DemoUtils.java
String[] stringArray={"A","B","C"};
public void getFirstThreeLettersOfAlphabet(){
    return stringArray;
}

DemoUtilsTest.java 
String[] stringArray={"A","B","C"};
assertArrayEquals(stringArray,DemoUtils.getFirstThreeLettersOfAlphabet(),Message);// It will return true 

////////////
assertIterableEquals()
Just replace stringArray with Any Iterable like ArrayList, LinkedList, HashSet. 


////////////
assertLinesMatch()----> assert that both lists of strings match 


-------------------------------------------------------------------------------


Assertions: Throws and Timeout
*************************************
assertThrows:- Assert that an executable throws an exception of expected type
assertDoesNotThrow(Lambda expression);

public class DemoUtils {
public String throwException(int a) throws Exception {
    if (a < 0) {
    throw new Exception("Value should be greater than or equal to 0");
    }
    return "Value is greater than or equal to 0";
    }
}

public class DemoUtilsTest{
    ..
    DemoUtils demoUtils = new DemoUtils();
    
    @DisplayName("Throws and Does Not Throw")
    @Test
    void testThrowsAndDoesNotThrow() {
        assertThrows(Exception.class, () -> { demoUtils.throwException(-1); }, "Should throw exception");
        assertDoesNotThrow(() -> { demoUtils.throwException(5); }, "Should not throw exception");
    }
}




assertTimeoutPreemtively:- Assert that an executable completes before given timeout is exceeded (execution is preemtively aborted if timeout exceeded)

public class DemoUtils {
public void checkTimeout() throws InterruptedException {
    System.out.println("I am going to sleep");
    Thread.sleep(2000);
    System.out.println("Sleeping over");
    }
}
We will make sure that method does not oversleep:-

class DemoUtilsTest {
DemoUtils demoUtils;
    ...
    @DisplayName("Timeout")
    @Test
    void testTimeout() {
    assertTimeoutPreemptively(Duration.ofSeconds(3), () -> { demoUtils.checkTimeout(); },"Method should execute in 3 seconds");
    }
}


---------------------------------------------------------------------------------------


Ordering Junit Tests
******************************

@TestMethodOrder:- Configures the order/sort algorithm for the test methods 

MethodOrderer.DisplayName:- Sort test methods alphanumerically based on display names 
MethodOrderer.MethodName:- Sort test method alphanumerically based on method names      (Don't use @DisplayName annotation(Sorted with MethodName but DisplayNames will be visible))
MethodOrderer.randon:- Pseudo-random order based on method names 
MethodOrderer.OrderAnnotation:- Sorts test methods numerically based on @Order annotation

@TestMethodOrder(MethodOrderer.DisplayName.class)
class DemoUtilsTest 

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class DemoUtilsTest


@Test
@Order(Order_Number)                        Lower number has highest priority. 
void testEqualsAndNotEquals()


---------------------------------------------------------------------------------------------------------

Code Coverage and Test Reports With Maven 
********************************
Run test in eclipse

Go to Project Main directory>>open cmd
mvn clean test (If not showing Any Test result), so need to configure maven to find unit tests:-
Add maven surefire plugin
<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>3.1.2</version>
			</plugin>
		</plugins>
</build>

Generate unit tests report:-
maven surefire report plugin can generate HTML unit test report:-
<plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-surefire-report-plugin</artifactId>
	<version>3.2.2</version>
	--To Do--
</plugin>


In To Do:-
<executions>
		<execution>
			<phase>test</phase>
				<goals>
					<goal>report</goal>
				</goals>
		</execution>
	</executions>
It means during, test phase execute plugin goal report. (maven-surefire-report-plugin:report)

mvn clean test (Run tests and executes Surefire Report plugin to generate HTML reports)
mvn site -DgenerateReports=false (Add website resources imgages,css etc...) (false== Don't overwrite existing HTML reports)


View Unit Test Reports:-
-----------------------------
target/site/surefire-report.html 


Handling Test Failures:-
--------------------------------
By Default, maven Surefire plugin will not generate reports if tests fail. 
<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>3.1.2</version>
                <configuration>
                    <testFailureIgnore>true</testEqualsAndNotEquals>
                </configuration>
			</plugin>
		</plugins>
</build>
Maven does not give report if test fails.


By default, maven surefire plugin will not show @DisplayName in reports
-----------------------------------------------------------------------------
maven.apache.org/surefire>> maven surefire plugin>> Using junit plateform>> ...for @DisplayName 
<plugin>
    ...
    <artifactId>maven-surefire-plugin</artifactId>
    ...
    <configuration>
        <testFailureIgnore>true</testFailureIgnore>
        <statelessTestsetReporter implementation="org.apache.maven.plugin.surefire.extensions.junit5.JUnit5Xml30StatelessReporter">
        <usePhrasedTestCaseMethodName>true</usePhrasedTestCaseMethodName>
    </statelessTestsetReporter>
    </configuration>
</plugin> 



---------------------------------------------------------------------------
Generate code coverate report:-
**********************************
JaCoCo is a free code coverage library. 
JaCoCo provides free maven plugin to generate code coverage reports. 
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.11</version>
    <executions>
        <execution>
            <id>jacoco-prepare</id>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>jacoco-report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>

mvn clean test 
target/site/JaCoCo/index.html

---------------------------------------------------------------------------------------------------------


Conditional Tests:-
***************************
We may not need to run all the tests ...
@Disabled:- Disable a test method 
@Disabled(Message)

@EnabledOnOs:- Enable test when when running on a given operating system.
@EnabledOnOs(OS.WINDOWS)
@EnabledOnOs({OS.MAC,OS.WINDOWS})

Annotations can be applied on class level or method level. 

@EnabledOnJre
@EnabledOnJre(JRE.JAVA_17)

@EnabledForJreRange
@EnabledForJreRange(MIN=JRE.JAVA_13,MAX=JRE.JAVA_17)
@EnabledForJreRange(MIN=JRE.JAVA_11)

@EnabledIfSystemProperty:-   Enable test based on system property 
@EnabledIfSystemProperty(named="LUV2CODE_SYS_PROP",matches="CI_CD_DEPLOY")

@EnabledIfEnvironmentVariable:-  Enable test based on environment variable 
@EnabledIfEnvironmentVariable(named="LUV2CODE_ENV",matches="DEV")


--------------------------------------------------------------------------------------------------------------

*******************************************
TEST DRIVEN DEVELOPMENT
*******************************************

Traditional development 
------------------------
Design----> Code----> Test 


TDD 
----
First, write a failing test----> Write Code to make the test pass----> Refactor and improve on design----> Repeat process for next test 


We will use FizzBuzz project as an example:-
Development process:-
Write a failing test 
Write code to make the test pass 
Refactor the code 
Repeat the process 

FizzBuzz
    src/main/java   
        com.devanshu.fizzbuzz 
            FizzBuzzApplication.java 
        com.devanshu.tdd 
    src/main/resources
    src/test/java 
        com.devanshu.tdd 
            FizzBuzzTest.java 
    ..
    ..
    pom.xml 



src/test/java 
    com.devanshu.tdd 
        FizzBuzzTest.java 
        @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
        class FizzBuzzTest {

            @DisplayName("divisible by three")
            @Test
            @Order(1)
            void testForDivisibilityByThree() {
                fail("fail");
            }
        }
Definitely it will fail. 

src/test/java 
    com.devanshu.tdd 
        FizzBuzzTest.java 
            @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
            class FizzBuzzTest {

                @DisplayName("divisible by three")
                @Test
                @Order(1)
                void testForDivisibilityByThree() {
                    String expected = "Fizz";
                    assertEquals(expected,FizzBuzz.compute(3),"It should return Fizz");
                }
            }
Definitely, unit test will fail.

src/main/java
    com.devanshu.tdd 
        FizzBuzz.java 
            public class Fizz{
                public static String compute(int i){
                    return null;
                }
            }
Definitely the unit test will fail. 

src/main/java
    com.devanshu.tdd 
        FizzBuzz.java 
            public class Fizz{
                public static String compute(int i){
                    if(i%3==0)
                        return "Fizz";
                    return null;
                }
            }
It will pass. 
..
..
and so on. 


Final code will be like:-
src/test/java 
    com.devanshu.tdd 
        FizzBuzzTest.java 
            @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
            class FizzBuzzTest {

                @DisplayName("divisible by three")
                @Test
                @Order(1)
                void testForDivisibilityByThree() {
                    String expected = "Fizz";
                    assertEquals(expected,FizzBuzz.compute(3),"should return Fizz");
                }
                @DisplayName("divisible by five")
                @Test
                @Order(2)
                void testForDivisibilityByFive() {
                    String expected = "Buzz";
                    assertEquals(expected,FizzBuzz.compute(5),"should return Buzz");
                }
                
                @DisplayName("divisible by three and five")
                @Test
                @Order(3)
                void testForDivisibilityByThreeAndFive() {
                    String expected = "FizzBuzz";
                    assertEquals(expected,FizzBuzz.compute(15),"should return FizzBuzz");
                }
                @DisplayName("divisible by three or five")
                @Test
                @Order(4)
                void testForDivisibilityByThreeOrFive() {
                    String expected = "7";
                    assertEquals(expected,FizzBuzz.compute(7),"should return 1");
                }
            }
src/main/java
    com.devanshu.tdd 
        FizzBuzz.java 
            public class FizzBuzz {
                public static String compute(int i) {
                    if(i%3==0 && i%5==0)
                        return "FizzBuzz";
                    if(i%3==0)
                        return "Fizz";
                    if(i%5==0)
                        return "Buzz";
                    return Integer.toString(i);
                }

            }


FizzBuzz code refactoring:-
--------------------------------
public static String compute(int i) {
		
		StringBuffer sb = new StringBuffer();
		
		if(i%3==0)
			sb.append("Fizz");
		if(i%5==0)
			sb.append("Buzz");
//		if(i%3!=0 && i%5!=0)
//			sb.append(i);
		if(sb.isEmpty())
			sb.append(i);
		
		return sb.toString();
}


Parameterized Test: Overview
-----------------------------------

@ParameterizedTest:- JUnit will run the test multiple times and supply the data (Does looping for us)
Source of Values 
@ValueSource--------> Array of values: Strings, ints, doubles, floats etc 
@CsvSource----------> Array of CSV string values 
@CsvFileSource------> CSV values read from a file 
@EnumSource---------> Enum constant values 
@MethodSource-------> Custom method for providing values 

Using @CsvFileSource 
---------------------
src/test/java 
    resources
        small-test-data.csv 
            1,1
            2,2
            3,Fizz 
            ..
            ..

        @TestMethodOrder(MethodOrderer.OrderAnnotation.class)
        class FizzBuzzTest
        {
             @DisplayName("Testing with small data file")
                @ParameterizedTest(name="value={0},expected={1}")
                @CsvFileSource(resources="/small-test-data.csv")
                @Order(5)
                void testSmallDataFile(int value,String expected) 
                {
                    assertEquals(expected,FizzBuzz.compute(value),"");
                }

        }
Now, write main application:-
src/main/java 
    com.devanshu.tdd 
        MainApp.java 
            public class MainApp {

                public static void main(String[] args) {
                    for(int i=1;i<=100;i++) {
                        System.out.println(FizzBuzz.compute(i));
                    }
                }

            }

       







Unit Test: Mocking with Mockito 
***************************************













